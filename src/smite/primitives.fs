CR .( Required primitives )

ALSO ASSEMBLER

\ Stack primitives
\ FIXME: Implement ROLL
CODE DROP   ] 1 [ BPOP BRET END-CODE  2 INLINE
CODE PICK   BPUSH BRET END-CODE  1 INLINE
CODE SWAP   ] 1 [ BSWAP BRET END-CODE  2 INLINE
CODE >R   BPOP2R BRET END-CODE  1 INLINE
CODE R>   BRPOP BRET END-CODE  1 INLINE
CODE R@   ] 1 [ BRPUSH BRET END-CODE
: CELL   4 ;
: -CELL   -4 ;

\ Stack management primitives
CODE SP@   BPUSH_SDEPTH CELL LITERAL, BMUL BRET END-CODE  3 INLINE
CODE SP!   CELL LITERAL, BUDIVMOD ] 1 [ BPOP BSTORE_SDEPTH BRET END-CODE  5 INLINE
CODE RP@   BPUSH_RDEPTH CELL LITERAL, BMUL BRET END-CODE  3 INLINE
CODE RP!   CELL LITERAL, BUDIVMOD ] 1 [ BPOP BSTORE_RDEPTH BRET END-CODE  5 INLINE
CODE S0   ] 0 [ BRET END-CODE  1 INLINE
CODE R0   ] 0 [ BRET END-CODE  1 INLINE
CODE STACK-CELLS   BPUSH_SSIZE BRET END-CODE  1 INLINE
CODE RETURN-STACK-CELLS   BPUSH_RSIZE BRET END-CODE  1 INLINE
CODE MEMORY@   BPUSH_MEMORY BRET END-CODE  1 INLINE

\ Memory primitives
CODE @   BLOAD BRET END-CODE  1 INLINE
CODE !   BSTORE BRET END-CODE  1 INLINE
CODE C@   BLOADB BRET END-CODE  1 INLINE
CODE C!   BSTOREB BRET END-CODE  1 INLINE

\ Arithmetic and logical primitives
CODE +   BADD BRET END-CODE  1 INLINE
CODE -   BNEGATE BADD BRET END-CODE  2 INLINE
1 PRIMITIVES NEGATE
CODE *   BMUL BRET END-CODE  1 INLINE
CODE U/MOD   BUDIVMOD ] 1 [ BSWAP BRET END-CODE
CODE S/REM   BDIVMOD ] 1 [  BSWAP BRET END-CODE
CODE =   BEQ BNEGATE BRET END-CODE  2 INLINE
CODE <   BLT BNEGATE BRET END-CODE  2 INLINE
CODE U<   BULT BNEGATE BRET END-CODE  2 INLINE
4 PRIMITIVES AND OR XOR INVERT
2 PRIMITIVES LSHIFT RSHIFT

\ Control primitives
INCLUDE" bracket-create.fs"
INCLUDE" bracket-does.fs"

\ System primitives
1 PRIMITIVES HALT

PREVIOUS
