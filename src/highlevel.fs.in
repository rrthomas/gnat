\ Gnat high level words
\
\ (c) Reuben Thomas 1991-2022
\
\ The package is distributed under the GNU GPL version 3, or, at your
\ option, any later version.
\
\ THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
\ RISK.

CR .( @PACKAGE_NAME@ high level words )


\ System variables

0 VALUE 'FORTH   \ set in per-platform INITIALIZE


\ Arithmetic #1

PROVIDE: TRUE   -1 ; [THEN]
PROVIDE: FALSE   0 ; [THEN]

8 CONSTANT BYTE-BITS \ FIXME: check assumption

PROVIDE: -   NEGATE + ; [THEN]

PROVIDE: 1+   1 + ; [THEN]
PROVIDE: 1-   1 - ; [THEN]
PROVIDE: -CELL   CELL NEGATE ; [THEN]
PROVIDE: CELL+   CELL + ; [THEN]
PROVIDE: CELL-   CELL - ; [THEN]


\ Stack manipulation #1

PROVIDE: DUP   0 PICK ; [THEN]
PROVIDE: OVER   1 PICK ; [THEN]
PROVIDE: ?DUP   DUP IF  DUP  THEN ; [THEN]
PROVIDE: ROLL
   DUP 1 + PICK  >R  DUP >R
   BEGIN  ?DUP WHILE
      SWAP  R> SWAP  >R >R
      1 -
   REPEAT
   DROP
   R> BEGIN  ?DUP WHILE
      R> SWAP
      1 -
   REPEAT
   R> ; [THEN]
PROVIDE: SWAP   1 ROLL ; [THEN]
PROVIDE: ROT   2 ROLL ; [THEN]
PROVIDE: -ROT   ROT ROT ; [THEN]
PROVIDE: TUCK   SWAP OVER ; [THEN]
PROVIDE: NIP   SWAP DROP ; [THEN]


\ Exceptions #1

[PROVIDED] THROW  INVERT [IF]
   VARIABLE 'THROW
   : 'THROW!   'THROW ! ;
   : THROW   'THROW @EXECUTE ;
[THEN]
VARIABLE 'THROWN
: (ABORT")   SWAP IF  'THROWN !  -2 THROW  ELSE DROP  THEN ;
: UNDEFINED   ( c-addr -- )   'THROWN !  -13 THROW ;
PROVIDE: BYE   0 HALT ; [THEN]


\ Arithmetic #2

PROVIDE: >-<   SWAP - ; [THEN]

PROVIDE: <   SWAP > ; [THEN]
PROVIDE: >   SWAP < ; [THEN]
PROVIDE: U<   SWAP U> ; [THEN]
PROVIDE: U>   SWAP U< ; [THEN]

PROVIDE: ARSHIFT   OVER OVER  RSHIFT -ROT
   NEGATE CELL-BITS +
   SWAP 0 <  SWAP LSHIFT  OR ; [THEN]

PROVIDE: <>   = INVERT ; [THEN]
PROVIDE: 0<   0 < ; [THEN]
PROVIDE: 0>   0 > ; [THEN]
PROVIDE: 0=   0 = ; [THEN]
PROVIDE: 0<>   0 <> ; [THEN]

PROVIDE: ABS   DUP 0< IF  NEGATE  THEN ; [THEN]

\ Allow division primitives without 0 divisor checking
\ Assume that if S/REM is provided, so is U/MOD
[PROVIDED] S/REM  INVERT [IF]
   : CHECK-DIVISOR DUP 0= IF -10 THROW THEN ;
   : S/REM CHECK-DIVISOR (S/REM) ;
   : U/MOD CHECK-DIVISOR (U/MOD) ;
   [PROVIDED] (/MOD) [IF]
      : /MOD CHECK-DIVISOR (/MOD) ;
   [THEN]
[THEN]

PROVIDE: /MOD   ( n1 n2 -- n3 n4 )
   DUP >R
   OVER OVER XOR -ROT
   S/REM SWAP DUP  3 PICK
   0< OVER  0<> AND  IF
      R@ ABS  SWAP ABS  -
      R> 0> IF  1  ELSE -1  THEN *
   ELSE
      R> DROP
   THEN
   >R
   0<> ROT  0< AND  +
   R> SWAP ; [THEN]
PROVIDE: /   /MOD NIP ; [THEN]
PROVIDE: MOD   /MOD DROP ; [THEN]

PROVIDE: 2*   1 LSHIFT ; [THEN]
PROVIDE: 2/   1 ARSHIFT ; [THEN]
PROVIDE: CELLS   CELL * ; [THEN]
PROVIDE: CELL/   CELL / ; [THEN]

: CELL-BITS   BYTE-BITS CELLS ;
: TOP-BIT-SET   1 CELL-BITS 1- LSHIFT ;


\ Control structures #1

PROVIDE: J   R> R> R> R>  DUP  -ROT >R >R  -ROT >R >R ; [THEN]
PROVIDE: (LOOP)   R>  R> 1+  DUP R@ =  SWAP >R  SWAP >R ; [THEN]
PROVIDE: (+LOOP)   R> SWAP  R>  R@ OVER SWAP -  -ROT +  R@ OVER SWAP -
   SWAP >R  XOR 0<  SWAP >R ; [THEN]
PROVIDE: UNLOOP   R>  R> DROP R> DROP  >R ; [THEN]


\ Stack manipulation #2

PROVIDE: 2DUP   OVER OVER ; [THEN]
PROVIDE: 2DROP   DROP DROP ; [THEN]
PROVIDE: 2SWAP   3 ROLL  3 ROLL ; [THEN]
PROVIDE: 2OVER   3 PICK  3 PICK ; [THEN]
PROVIDE: 2ROT   5 ROLL  5 ROLL ; [THEN]

PROVIDE: 2>R   R> -ROT  SWAP >R >R  >R ; COMPILING [THEN]
PROVIDE: 2R>   R>  R> R> SWAP  ROT >R ; COMPILING [THEN]
PROVIDE: 2R@   R>  R> R>  2DUP >R >R  SWAP  ROT >R ; COMPILING [THEN]

: STACK-DIRECTION   SP@ SP@ - 0<  NEGATE 2* 1- ;
: DEPTH   SP@ S0 -  CELL/  STACK-DIRECTION * ;


\ Memory #1

PROVIDE: +!   TUCK @  +  SWAP ! ; [THEN]


\ Characters

: +CHAR   1 ;
: -CHAR   -1 ;
: CHAR+   1+ ;
: CHAR-   1- ;
: CHARS ; IMMEDIATE
: CHAR/ ; IMMEDIATE


\ Arithmetic #4

PROVIDE: MIN   2DUP > IF  SWAP  THEN  DROP ; [THEN]
PROVIDE: MAX   2DUP < IF  SWAP  THEN  DROP ; [THEN]


\ Strings #1

: COUNT   DUP CHAR+ SWAP C@ ;
: CMOVE   CHARS OVER + SWAP ?DO  DUP C@ I C! CHAR+  +CHAR +LOOP  DROP ;
: CMOVE>   ?DUP IF  CHARS CHAR- TUCK  + -ROT  OVER +  DO  I C@ OVER C!  CHAR-
   -CHAR +LOOP  ELSE DROP  THEN  DROP ;
: MOVE   -ROT 2DUP > IF  ROT CMOVE  ELSE ROT CMOVE>  THEN ;
: FILL   -ROT  CHARS OVER + SWAP ?DO  DUP I C!  +CHAR +LOOP  DROP ;
: ERASE   0 FILL ;


\ Compiler #1

\ These words are defined in compiler-asm.fs
DEFER .ALIGN
DEFER .CALIGN
DEFER .REL-OFFSET
DEFER .NOP
DEFER .ALLOT
DEFER .ALLOT-CELLS
DEFER .WORD
DEFER .BYTE
DEFER .STRING
DEFER .PUSHI
DEFER .PUSHRELI
DEFER .PUSH
DEFER .LABEL
DEFER .LABEL-DEF
DEFER .BODY-LABEL-DEF
DEFER .BRANCH
DEFER .IF
DEFER .RET
DEFER .IMMEDIATE-METHOD
DEFER .COMPILE-METHOD
DEFER .CALL-COMPILE-METHOD
DEFER .INLINE-COUNT
DEFER .CREATED-CODE
DEFER .PUSHRELI-SYMBOL

0 VALUE DP
: HERE   DP @ ;
: RAW-ALLOT   HERE OVER ERASE  DP +! ;
: ALLOT   DUP .ALLOT  RAW-ALLOT ;
: ALLOT-CELLS   DUP .ALLOT-CELLS   CELLS RAW-ALLOT ;

VARIABLE ROOTDP

: ALIGNED   CELL+ 1-  -CELL AND ;
: ALIGN   .ALIGN  HERE ALIGNED  DP ! ;
: RAW,   HERE  CELL RAW-ALLOT  ! ;
: ,   DUP .WORD  RAW, ;
: RAW-C,   HERE  +CHAR RAW-ALLOT  C! ;
: C,   DUP .BYTE  RAW-C, ;
: CALIGN   HERE  DUP ALIGNED  >-< 0 ?DO  DUP RAW-C,  LOOP  .CALIGN ;

: >REL   ( from to -- offset )   DUP IF  >-<  ELSE NIP  THEN ;
: RAW-REL,   HERE SWAP >REL RAW, ;
: REL,   DUP RAW-REL,  .REL-OFFSET ;
: REL@   DUP @  ?DUP IF  +  ELSE DROP 0  THEN ;
: REL!   ( to 'link -- )   DUP  ROT >REL  SWAP ! ;

VARIABLE STATE
: [   0 STATE ! ; IMMEDIATE COMPILING
: ]   1 STATE ! ;

VARIABLE #ORDER
CREATE CONTEXT  8 ALLOT-CELLS \ FIXME: constant

VARIABLE CURRENT
: GET-CURRENT   CURRENT @ ;
: SET-CURRENT   CURRENT ! ;
: LAST   GET-CURRENT  REL@ ;

: >LINK   3 CELLS - ;
: >COMPILE   2 CELLS - ;
: >INFO   CELL- ;
: >NAME   DUP >INFO CELL 1- + C@  31 AND 1+ CHARS ALIGNED  SWAP >LINK  >-< ;

: IMMEDIATE-BIT   TOP-BIT-SET ;
: SET-IMMEDIATE   LAST >INFO  DUP @  IMMEDIATE-BIT OR  SWAP ! ;
: IMMEDIATE   SET-IMMEDIATE  LAST >NAME .IMMEDIATE-METHOD
   LAST DUP >COMPILE  REL! ;
: COMPILING-BIT   TOP-BIT-SET 1 RSHIFT ;
: COMPILING   LAST >INFO  DUP @  COMPILING-BIT OR  SWAP ! ;
: SMUDGE-BIT   TOP-BIT-SET 2 RSHIFT ;
: SMUDGE!   ( f a-addr -- )   >INFO  TUCK @  SMUDGE-BIT DUP INVERT  ROT AND
   -ROT AND  OR  SWAP ! ;
: SMUDGE   ( f -- )   LAST  SMUDGE! ;


\ Interpreter #1

CREATE TOKEN  256 ALLOT
: TOKEN-END   TOKEN 256 + ;
CREATE S"B  256 ALLOT
CREATE SCRATCH  256 ALLOT


\ Writing code to memory

\ Default naive implementation.
: CODE!   ( x adr -- )   ! ;
: CODE,   ( x -- )   , ;
: CODE-MOVE   CELLS OVER + SWAP ?DO  DUP @  I CODE!  CELL+
   CELL +LOOP  DROP ;


\ Machine-dependent words

INCLUDE" opcodes.fs"


\ Core compiler

: CALL   ( at from to -- )   >-< SWAP ! ;

: NOP,   INSN_NOP OP2_INSN >OPCODE2 RAW, ;
: CALL,   HERE SWAP OFFSET CELL/ OP_CALLI >OPCODE RAW, ;
: BRANCH,   0 OP2_JUMPI >OPCODE2 RAW, ;
: IF,   0 OP2_JUMPZI >OPCODE2 RAW, ;
: PUSH,   ( x -- )
   DUP CELLS CELL/  OVER = IF
      OP_PUSHI >OPCODE RAW,
   ELSE
      HERE 2 CELLS + CALL,  RAW,  INSN_POPR OP2_INSN >OPCODE2 RAW,  INSN_LOAD OP2_INSN >OPCODE2 RAW,
   THEN ;
: PUSHREL,   HERE SWAP OFFSET CELL/ OP_PUSHRELI >OPCODE RAW, ;

: @BRANCH   ( from -- to )   DUP @ OP2_SHIFT ARSHIFT CELLS + ;
: !BRANCH   ( from to -- )   OVER SWAP OFFSET CELL/  OVER @ OPCODE2>  >OPCODE2  SWAP ! ;
: COMPILE,   DUP >INFO 2 + C@  ?DUP IF  0 DO  DUP @ ,  CELL+  LOOP  DROP
   ELSE CALL,  THEN ;

: ADDR>LABEL   'FORTH - CELL/ ;
CHAR b CONSTANT BACKWARD
CHAR f CONSTANT FORWARD
CHAR n CONSTANT NONAME

: BEGIN   HERE  DUP BACKWARD .LABEL-DEF ; IMMEDIATE COMPILING
: AHEAD   HERE  DUP FORWARD .BRANCH  BRANCH, ; IMMEDIATE COMPILING
: IF   HERE  DUP FORWARD .IF  IF, ; IMMEDIATE COMPILING

: THEN   DUP FORWARD .LABEL-DEF  HERE !BRANCH ; IMMEDIATE COMPILING

: LINK, ;
: UNLINK,   .RET  INSN_RET OP2_INSN >OPCODE2 RAW, ; COMPILING
: LEAVE, ;


DEFER CURRENT-COMPILE,  ' COMPILE, IS CURRENT-COMPILE,
: (POSTPONE)   CURRENT-COMPILE, ;
VARIABLE CREATED   \ Indicate whether last word was CREATEd


\ Data structures

: LITERAL
   DUP
   DUP CELLS CELL/  OVER = IF  .PUSHI  ELSE  .PUSH  THEN
   PUSH, ; IMMEDIATE COMPILING
: RELATIVE-LITERAL   DUP .PUSHRELI  PUSHREL, ; IMMEDIATE COMPILING

: >BODY   2 CELLS + ;
\ >DOES>, given the xt of a defining word, returns the address of the DOES>
\ code.
: >DOES>   ( xt -- 'does )   DUP >INFO @ $FFFF AND CELLS  + ;
: (DOES>)   DUP >NAME CREATED !  >DOES>  LAST CELL+  DUP ROT CALL ;


\ Compiler words that need special treatment during meta-compilation owing
\ to their use of POSTPONE

: AGAIN   DUP BACKWARD .BRANCH  HERE BRANCH, SWAP !BRANCH ; IMMEDIATE COMPILING
: UNTIL   DUP BACKWARD .IF  HERE IF, SWAP !BRANCH ; IMMEDIATE COMPILING

: DOES-LINK,   POSTPONE R> ;

: DO,   POSTPONE 2>R ; COMPILING
: LOOP,   POSTPONE (LOOP)  POSTPONE UNTIL ; COMPILING
: +LOOP,   POSTPONE (+LOOP)  POSTPONE UNTIL ; COMPILING
: END-LOOP,   POSTPONE UNLOOP ; COMPILING

: CREATE,   .NOP  NOP,  ['] (CREATE) CALL,
   LAST >NAME .CREATED-CODE
   ['] (CREATE) >NAME  CREATED ! ;


\ Defer address fetch/store
\ Defined early so they can be POSTPONEd

: DEFER!   >BODY REL! ;
: DEFER@   >BODY REL@ ;


\ Strings #2

\ Copy string c-addr1 u1 into buffer c-addr2 u2, and NUL-terminate it
: C0END   ( c-addr1 u1 c-addr2 u2 -- )   1- ROT MIN  2DUP + >R
   MOVE  0 R> C! ;
\ FIXME: caller should allocate buffer!
: SCRATCH-C0END   ( c-addr1 u1 -- HERE )   SCRATCH 256 C0END  SCRATCH ;
: ",   ( c-addr u -- )   DUP C,  2DUP .STRING   HERE SWAP  DUP RAW-ALLOT  CMOVE ;

: (C")   R>  DUP C@ 1+ CHARS OVER + ALIGNED  >R ;
: (S")   R>  DUP C@  TUCK 1+ CHARS OVER + ALIGNED  >R
   CHAR+ SWAP ;


INCLUDE" fileio.fs"
INCLUDE" terminal.fs"   \ terminal I/O words


\ Interpreter #2

: ABORT   -1 THROW ;
: QUIT   -56 THROW ;


\ Control structures #2

: WHILE   POSTPONE IF  1 ROLL ; IMMEDIATE COMPILING
: REPEAT   POSTPONE AGAIN  POSTPONE THEN ; IMMEDIATE COMPILING
: ELSE   POSTPONE AHEAD  1 ROLL  POSTPONE THEN ; IMMEDIATE COMPILING

VARIABLE 'NODE
VARIABLE 'LOOP
: NEW-NODE
   'NODE @ 'LOOP @
   HERE  CELL 1- INVERT AND
   DUP 'LOOP ! 'NODE ! ;
: TIE-NODE
   'LOOP @ FORWARD .LABEL-DEF
   'NODE @
   BEGIN
      DUP 'LOOP @ <> WHILE
      DUP @BRANCH SWAP  POSTPONE THEN
   REPEAT DROP
   'LOOP ! 'NODE ! ;
: I   POSTPONE R@ ; IMMEDIATE COMPILING
: LEAVE   LEAVE,  'LOOP @ FORWARD .BRANCH  HERE  'NODE  DUP @  HERE BRANCH, SWAP !BRANCH  ! ; IMMEDIATE COMPILING
: DO   NEW-NODE  DO,  POSTPONE BEGIN ; IMMEDIATE COMPILING
: ?DO   NEW-NODE  POSTPONE 2DUP DO, POSTPONE = POSTPONE IF
   POSTPONE LEAVE POSTPONE THEN  POSTPONE BEGIN ; IMMEDIATE COMPILING
: LOOP   LOOP,  TIE-NODE  END-LOOP, ; IMMEDIATE COMPILING
: +LOOP   +LOOP,  TIE-NODE  END-LOOP, ; IMMEDIATE COMPILING

: RECURSE   LAST COMPILE, ; IMMEDIATE COMPILING

: CASE   0 ; IMMEDIATE COMPILING
: OF   1+ >R  POSTPONE OVER POSTPONE = POSTPONE IF  POSTPONE DROP  R> ;
IMMEDIATE COMPILING
: ENDOF   >R  POSTPONE ELSE  R> ; IMMEDIATE COMPILING
: ENDCASE   POSTPONE DROP  0 ?DO  POSTPONE THEN  LOOP ; IMMEDIATE COMPILING


: CLITERAL   POSTPONE (C")  ", 0 CALIGN ; IMMEDIATE COMPILING
: SLITERAL   POSTPONE (S")  ", 0 CALIGN ; IMMEDIATE COMPILING


\ Memory #2

: 2@   DUP CELL+ @  SWAP @ ;
: 2!   TUCK !  CELL+ ! ;
: 2,   , , ;


\ Strings #3

: BLANK   BL FILL ;

: COMPARE   ( c-addr1 u1 c-addr2 u2 -- n )
   ROT 2SWAP 2OVER MIN               \ no. of characters to check
   DUP 0> IF                         \ if strings not both length 0
      0 DO                           \ for each character
         OVER C@  OVER C@            \ get the characters
         <> IF                       \ if they're unequal
            C@ SWAP  C@              \ retrieve the characters
            < 2* INVERT              \ construct the return code
            NIP NIP UNLOOP EXIT      \ and exit
         THEN
         CHAR+ SWAP  CHAR+ SWAP      \ increment addresses
      LOOP
      2DROP                          \ get rid of addresses
      2DUP <> -ROT < 2* INVERT AND   \ construct return code
   ELSE                              \ if strings are both length 0
      2DROP 2DROP                    \ leave 0
   THEN ;

: SEARCH   ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 f )
   ROT 2DUP                          \ copy lengths
   OVER SWAP U>  SWAP 0=  OR IF      \ if u2>u1 or u2=0
      NIP NIP  FALSE EXIT            \ exit with false flag
   THEN
   -ROT 2OVER                        \ save c-addr1 u1
   2SWAP TUCK 2>R                    \ save c-addr2 u2
   - 1+ OVER +  SWAP                 \ make c-addr1 c-addr1+u1-u2
   2R> 2SWAP                         \ retrieve c-addr2 u2
   DO
      2DUP I OVER COMPARE 0= IF      \ if we find the string
         2DROP +  I TUCK -           \ calculate c-addr3 u3
         TRUE UNLOOP EXIT            \ exit with true flag
      THEN
   LOOP
   2DROP FALSE ;                     \ leave c-addr1 u1 false


\ Control structures #3

: "CASE   POSTPONE CASE ; IMMEDIATE COMPILING
: "OF   1+ >R  POSTPONE 2OVER POSTPONE COMPARE POSTPONE 0= POSTPONE IF
  POSTPONE 2DROP  R> ; IMMEDIATE COMPILING
: "ENDOF   POSTPONE ENDOF ; IMMEDIATE COMPILING
: "ENDCASE   POSTPONE 2DROP  0 ?DO  POSTPONE THEN  LOOP ; IMMEDIATE COMPILING


\ Mass storage input/output #1

: READ-LINE   ( c-addr u1 fid -- u2 flag ior )
   >R  OVER SWAP                     \ save fid and copy c-addr
   R@ READ-FILE                      \ fill buffer
   ?DUP IF                           \ if an error occurred
      NIP NIP 0 FALSE ROT            \ leave 0 false ior
      R> DROP  EXIT                  \ drop fid and exit
   THEN
   DUP 0= IF                         \ if the line is of length 0,
      NIP FALSE 0  R> DROP  EXIT     \ exit with false flag
   THEN
   TUCK                              \ save no. of chars read
   EOL SEARCH  ROT DROP              \ search for EOL; drop address
   IF                                \ if found,
      TUCK -  SWAP                   \ calculate length, save it
      EOL NIP - ?DUP IF              \ if not at the end of the line,
         R@ FILE-POSITION            \ get the current file position
         ?DUP IF                     \ if an error occurred
            >R 2DROP  FALSE R>       \ clear up, leave false flag
            R> DROP  EXIT            \ and ior, and exit
         THEN
         >-<                         \ set pointer to just after EOL
         R@ REPOSITION-FILE
         ?DUP IF                     \ if there was an error
            FALSE SWAP  R> DROP  EXIT \ exit with error code
         THEN
      THEN
   ELSE
      DROP                           \ else u2=u1
   THEN
   R> DROP                           \ drop fid
   TRUE 0 ;                          \ leave true flag, ior=0
: WRITE-LINE   ( c-addr u fid -- ior )
   >R                                \ save fid
   R@ WRITE-FILE                     \ write the line
   ?DUP IF                           \ if there was an error
      R> DROP  EXIT                  \ drop fid and exit
   THEN
   EOL R> WRITE-FILE ;               \ write the line terminator;
                                     \ ior is WRITE-FILE's result


\ Terminal input/output #1

: SPACE   BL EMIT ;
: SPACES   0 ?DO  SPACE  LOOP ;
: TYPE   CHARS OVER + SWAP ?DO  I C@ EMIT  +CHAR +LOOP ;
: -TRAILING   BEGIN  DUP IF  2DUP 1- CHARS + C@  BL =  ELSE FALSE  THEN
   WHILE  1-  REPEAT ;


\ Mass storage input/output #2

1024 CONSTANT /FILE-BUFFER
16 CONSTANT #FILE-BUFFERS
VARIABLE FILE-BUFFER#  0 ' FILE-BUFFER# >BODY !   \ next file buffer to use
CREATE FIRST-FILE  #FILE-BUFFERS /FILE-BUFFER * ALLOT
: ALLOCATE-BUFFER   ( -- c-addr ior )   FILE-BUFFER# @  DUP #FILE-BUFFERS
   = IF  -1  ELSE DUP 1+ FILE-BUFFER# !  /FILE-BUFFER *  FIRST-FILE +  0
   THEN ;
: FREE-BUFFER   ( -- ior )   FILE-BUFFER#  DUP @ 0= IF  DROP -1
   ELSE -1 SWAP +!  0  THEN ;


\ Terminal input/output #2

: ACCEPT   ( c-addr +n1 -- +n2 )   STDIN READ-LINE  2DROP ;

VARIABLE >IN

VARIABLE EVALUAND
VARIABLE #EVALUAND

VARIABLE #TIB
CREATE TIB  256 ALLOT

VARIABLE #FIB
0 VALUE FIB

0 VALUE SOURCE-ID
: SOURCE
   CASE SOURCE-ID
      -1 OF  EVALUAND @  #EVALUAND @  ENDOF
      0 OF  TIB  #TIB @  ENDOF
      >R  FIB  #FIB @  R>
   ENDCASE ;

\ SAVE-INPUT returns the current input source immediately under the number of
\ items returned, encoded as:
\       0 = user input device, -1 = string, 1 = file
: SAVE-INPUT   ( -- xn...x1 n )
   >IN @                             \ get >IN
   CASE SOURCE-ID                    \ look at SOURCE-ID
      0 OF  0 2  ENDOF               \ if 0, leave >IN 0
      -1 OF                          \ if -1, leave >IN EVALUAND
         EVALUAND @ #EVALUAND @      \ #EVALUAND -1
         -1 4
      ENDOF
      >R  FIB #FIB @ SOURCE-ID 1 5  R>
      \ if a file leave >IN FIB #FIB fid 1
   ENDCASE ;
: RESTORE-INPUT   ( xn...x1 n -- )
   DROP
   CASE
      0 OF  0 TO SOURCE-ID  ENDOF
      1 OF  TO SOURCE-ID  #FIB !  TO FIB  ENDOF
      -1 OF  #EVALUAND ! EVALUAND !  -1 TO SOURCE-ID
      ENDOF
   ENDCASE
   >IN ! ;

VARIABLE 'RETURN
: SAVE-INPUT>R   \ save input specification to return stack
   R> 'RETURN !                      \ save return address
   SAVE-INPUT                        \ get input specification
   DUP                               \ push it to return stack
   BEGIN  ?DUP WHILE                 \ can't use a DO loop as this would
      ROT >R                         \ interfere with the return stack
      1-
   REPEAT
   >R
   'RETURN @ >R ;                    \ restore return address
: R>RESTORE-INPUT   \ restore input specification from return stack
   R> 'RETURN !                      \ save return address
   R> DUP                            \ pop input specification
   BEGIN  ?DUP WHILE                 \ from return stack
      R> -ROT                        \ can't use a DO loop as this would
      1-                             \ interfere with the return stack
   REPEAT
   RESTORE-INPUT                     \ set input specification
   'RETURN @ >R ;                    \ restore return address

DEFER SCAN-TEST
LAST >NAME ' .DEFER-ABORT TO-ASMOUT
: SCAN   ( char xt -- c-addr u )
   IS SCAN-TEST
   SOURCE CHARS                      \ get input source
   OVER +                            \ end of input buffer + 1
   SWAP >IN @ CHARS +                \ start of parse area
   SWAP ROT  OVER 3 PICK ?DO         \ save start & end of input buffer
      DUP I C@ SCAN-TEST IF          \ if test true,
         NIP  I SWAP  LEAVE          \ drop end, leave I and exit
      THEN
   +CHAR +LOOP                       \ if end of loop reached, end left
   DROP                              \ get rid of delimiter
   OVER -  DUP >IN +!                \ advance >IN
   CHAR/ ;                           \ leave count and length

: PARSE   ( char -- c-addr u )
   ['] = SCAN                        \ search for delimiter
   >IN DUP @ CHAR+                   \ advance >IN past delimiter
   SOURCE NIP  MIN SWAP ! ;          \ making sure it stays in the source

: WORD   ( char -- c-addr )
   DUP                               \ copy delimiter
   ['] <> SCAN  2DROP                \ skip delimiter
   PARSE                             \ get the delimited string
   TOKEN  2DUP C!                    \ store count
   CHAR+  2DUP +  BL SWAP C!         \ store blank at end of string
   SWAP CMOVE                        \ store string
   TOKEN ;                           \ leave the string's address

: .(   [CHAR] ) PARSE TYPE ; IMMEDIATE

\ Set default PROGRAM-NAME in case for some reason there is no ARG 0
HERE  DUP BACKWARD .LABEL-DEF  S" @PACKAGE@" ",  CREATE "PROGRAM-NAME  REL,

: ERROR-PREFIX   "PROGRAM-NAME REL@ COUNT TYPE  S" : " TYPE ;


\ Compiler #2

: C"   [CHAR] " PARSE  POSTPONE CLITERAL ; IMMEDIATE COMPILING
: S"   [CHAR] " PARSE  S"B SWAP 2DUP 2>R  CMOVE  2R> ;
   :NONAME   [CHAR] " PARSE  POSTPONE SLITERAL ;IMMEDIATE

: ."   POSTPONE S"  POSTPONE TYPE ; IMMEDIATE COMPILING

: CHAR   BL WORD  CHAR+ C@ ;
: [CHAR]   CHAR  POSTPONE LITERAL ; IMMEDIATE COMPILING


\ Interpreter #3

: ABORT"   POSTPONE C"  POSTPONE (ABORT") ; IMMEDIATE COMPILING


\ Numeric conversion

VARIABLE BASE
VARIABLE HELD

: DECIMAL   10 BASE ! ;
: HEX   16 BASE ! ;
: HOLD   -CHAR HELD +!  HELD @ C! ;
: SIGN   0< IF  [CHAR] - HOLD  THEN ;
: <#   TOKEN-END HELD ! ;
: #>   DROP  HELD @  TOKEN-END OVER - ;
: #   BASE @ U/MOD  SWAP  DUP 10 < IF  [CHAR] 0 +
   ELSE [ CHAR A 10 - ] LITERAL +  THEN  HOLD ;
: #S   BEGIN  #  DUP 0= UNTIL ;

: .R   SWAP DUP ABS  <# #S SWAP SIGN #>  ROT OVER -  0 MAX SPACES  TYPE ;
: .   0 .R  SPACE ;
: DEC.   BASE @ SWAP  DECIMAL .  BASE ! ;
: U.R   .R ;
: U.   0 .R  SPACE ;
: H.   BASE @  SWAP HEX U.  BASE ! ;

: >NUMBER   ( u1 c-addr1 u2 -- u3 c-addr2 u4 )
   DUP IF                            \ if something to convert
      CHARS OVER + SWAP              \ form limits for a loop
      TUCK  OVER >R                  \ save initial address and
                                     \ address of last character + 1
      DO
         C@                          \ get next character
         DUP [CHAR] A < IF           \ convert to a digit
            [CHAR] 0 -  ELSE [ CHAR A 10 - ] LITERAL -
         THEN
         DUP  BASE @ - 0< INVERT     \ if digit is too large...
         OVER 0<  OR IF              \ or too small
            DROP I  LEAVE            \ leave address of character
         THEN                        \ and exit the loop
         >R BASE @ *                 \ multiply n by BASE
         R> +                        \ add new digit
         I CHAR+                     \ address of next character
      LOOP
      DUP R> >-<                     \ construct u'
   THEN ;
: SKIP-CHAR   ( c-addr u -- c-addr+1 u-1)   1- SWAP  CHAR+ SWAP ;
: NUMBER   ( c-addr -- n )
   DUP >R                            \ save address of string
   0 SWAP                            \ make accumulator for >NUMBER
   COUNT                             \ count the string
   BASE @ >R                         \ save BASE
   CASE  OVER C@                     \ set base if leading #, $ or %
      [CHAR] # OF  10 BASE !  SKIP-CHAR  ENDOF
      [CHAR] $ OF  16 BASE !  SKIP-CHAR  ENDOF
      [CHAR] % OF   2 BASE !  SKIP-CHAR  ENDOF
   ENDCASE
   OVER C@                           \ get the leading character
   [CHAR] - =  DUP >R  IF            \ skip first character if it's
      SKIP-CHAR                      \ a minus and save the flag
   THEN
   BEGIN
      >NUMBER                        \ convert up to non-digit
      ?DUP WHILE                     \ if the string's not finished,
      OVER C@ 4 / 11 <> IF           \ is the non-digit punctuation?
         R>                          \ FIXME: Tighten up parsing
         R> BASE !  R> UNDEFINED     \ if not, then not a number
      THEN
      SKIP-CHAR                      \ if so, skip the punctuation
   REPEAT
   DROP                              \ drop string address
   R>                                \ retrieve leading minus flag
   IF  NEGATE  THEN                  \ if leading minus, negate no.
   R> BASE !                         \ restore BASE
   R> DROP ;                         \ drop address of string


\ Compiler #3

: DEFINITIONS   CONTEXT @  SET-CURRENT ;

: GET-ORDER   #ORDER @  DUP IF  DUP >R  CELLS  CONTEXT TUCK + CELL-  DO
   I @  -CELL +LOOP  R>  THEN ;

DEFER VISIBLE?   \ word visibility test
LAST >NAME ' .DEFER-ABORT TO-ASMOUT
: ALL-VISIBLE   ( wid xt n -- true )   2DROP DROP  TRUE ;
\ VISIBLE? must be set before VET-WORDLIST is called, with a word whose
\ stack effect is ( wid xt n -- f ), where wid is the word list and xt the
\ execution token of the found word and n its immediacy flag, and f is true
\ if the word is deemed visible by the test.
: VET-WORDLIST   ( c-addr u wid -- 0 | xt 1 | xt -1 )
   DUP >R                            \ save wid
   BEGIN  REL@ ?DUP WHILE            \ for all words in list
      DUP >NAME                      \ get name field address
      2OVER ROT COUNT                \ COUNT the strings
      COMPARE 0= IF                  \ if the name matches
         DUP >INFO @                 \ and the word is not SMUDGEd
         SMUDGE-BIT AND 0= IF
            R@ OVER                  \ get wid and xt of word
            DUP >INFO @ 0< 2* INVERT \ get immediacy flag
            DUP >R                   \ save flag
            VISIBLE? IF              \ if word is deemed visible
               NIP NIP  R>  R> DROP  \ get flag, drop string and wid,
               EXIT                  \ and exit
            ELSE
               R> DROP               \ else drop immediacy flag
            THEN
         THEN
      THEN
      >LINK                          \ leave next link field
   REPEAT
   2DROP  R> DROP                    \ get rid of c-addr, u and wid,
   0 ;                               \ and set flag to 0
: SEARCH-WORDLIST   ( c-addr u wid -- 0 | xt 1 | xt -1 )
   ['] ALL-VISIBLE IS VISIBLE?  VET-WORDLIST ;

: SELECT   ( a-addr1 xt -- a-addr2 n )
   IS VISIBLE?                       \ set up visibility selector
   >R  GET-ORDER  R> SWAP            \ get search order
   ?DUP IF                           \ if search order non-empty
      1 SWAP DO                      \ for each word list in order
         TUCK COUNT ROT VET-WORDLIST \ search it
         ?DUP IF                     \ if the word is found
            I -ROT  2>R              \ save xt and immediacy flag
            0 DO  DROP  LOOP         \ drop wids and string address
            2R> UNLOOP EXIT          \ retrieve results and exit
         THEN
      -1 +LOOP
   THEN
   0 ;                               \ if not found leave string & 0 flag
: FIND   ( c-addr -- a-addr n )   ['] ALL-VISIBLE SELECT ;

DEFER CURRENT-LITERAL  ' LITERAL IS CURRENT-LITERAL
DEFER CURRENT-RELATIVE-LITERAL  ' RELATIVE-LITERAL IS CURRENT-RELATIVE-LITERAL
: POSTPONE
   BL WORD  DUP FIND
   ?DUP 0= IF  UNDEFINED  THEN
   0> IF
      >COMPILE REL@  CALL,  .CALL-COMPILE-METHOD
   ELSE
      PUSHREL,  .PUSHRELI-SYMBOL  ['] (POSTPONE) CURRENT-COMPILE,
   THEN ;
IMMEDIATE COMPILING


\ Name mangling
: ISDIGIT   DUP [CHAR] 0 < INVERT  SWAP [CHAR] 9 > INVERT  AND ;
: ISUPPER   DUP [CHAR] A < INVERT  SWAP [CHAR] Z > INVERT  AND ;
: ISLOWER   DUP [CHAR] a < INVERT  SWAP [CHAR] z > INVERT  AND ;
: ISALPHA   DUP ISUPPER  SWAP ISLOWER  OR ;
: ISALNUM   DUP ISDIGIT  SWAP ISALPHA  OR ;
: 2.H   BASE @ >R  HEX  <# # # #>  R> BASE !  TYPE ;
: .MANGLE   ( c-addr u -- ) \ print a Forth name mangled
   OVER + SWAP  ?DO
      I C@  DUP ISALPHA IF              \ output letters literally (FIXME: only mangle leading digit)
         EMIT
      ELSE                              \ escape everything else
         [CHAR] _ EMIT  2.H  [CHAR] _ EMIT
      THEN
   LOOP ;

\ A header has the following structure:
\
\  Name field                         counted string, up to 32 chars, space-padded to cell
\  Link field                         1 cell, relative link to LAST
\  Compilation method                 1 cell, relative pointer
\  Info field                         1 cell: MS byte bit 7 is IMMEDIATE flag,
\                                     bit 6 is COMPILING flag,
\                                     bit 5 is SMUDGE flag,
\                                     rest of MS byte is length of name field,
\                                     bytes 2-(MS byte - 1) are reserved for the back-end
\                                     bytes 0 & 1 are offset in cells to DOES> code for a
\                                     defining word
: .NAME   COUNT  .MANGLE ;
: .NAME-LABEL   DUP ." .global " .NAME CR  .NAME ." :" CR ;
: (.LINK)   ." .word " ?DUP IF >NAME .NAME ELSE ." . " THEN ."  - ." CR ;
: .LINK   ['] (.LINK) TO-ASMOUT ;
: .COMPILE-FIELD   ." .word " .NAME ." _compilation" CR ;
\ FIXME: put values for DOES> code, inline code, IMMEDIATE and COMPILING bits into an expression
: .INFO-FIELD   ." .word " .NAME ." _info " CR ;
: .INFO   ." .set " .NAME ." _info, "
   DUP IMMEDIATE-BIT AND IF ." _immediate_bit" ELSE ." 0" THEN
   IMMEDIATE-BIT INVERT AND  ."  | "
   DUP COMPILING-BIT AND IF ." _compiling_bit" ELSE ." 0" THEN
   COMPILING-BIT INVERT AND  ."  | "
   DUP SMUDGE-BIT AND IF ." _smudge_bit" ELSE ." 0" THEN
   SMUDGE-BIT INVERT AND  ."  | "
   CELL-BITS BYTE-BITS -  2DUP  RSHIFT ." (" . ." <<" ." _name_length_bits) | 0x"
   1 SWAP LSHIFT 1- AND  H. CR ;
: .PREVIOUS-INFO   LAST  DUP >INFO @  SWAP >NAME  ['] .INFO TO-ASMOUT ;
: .DOES   ." .set " .NAME ." _doer, " .NAME ." _does" CR ;
: .DOES-LABEL   .NAME ." _does:" CR ;
: .CREATED   LAST >NAME  ['] .DOES TO-ASMOUT ;
: .SYMBOL
   DUP >INFO CELL 1- + C@ IF
      >NAME .NAME
   ELSE
      NONAME .LABEL
   THEN ;
: HEADER   ( c-addr -- )
   LAST IF                           \ output previous word's info field
      .PREVIOUS-INFO
      CREATED @ ?DUP IF  .CREATED  THEN
   THEN
   FALSE CREATED !
   DUP >R                            \ save name
   ALIGN                             \ align DP for new definition
   DUP C@ 31 MIN                     \ get name (max. 31 chars)
   OVER C!                           \ set length
   COUNT
   2DUP GET-CURRENT SEARCH-WORDLIST IF \ check name is unique
      DROP 2DUP TYPE ."  is not unique "
   THEN
   TUCK                              \ save length
   ",                                \ write name in name field
   BL CALIGN                         \ pad with spaces to next cell boundary
   LAST .LINK                        \ store link to last word
   LAST RAW-REL,
   R@ ['] .COMPILE-FIELD TO-ASMOUT   \ compilation method field
   0 RAW,
   R@ ['] .INFO-FIELD TO-ASMOUT
   CELL-BITS BYTE-BITS - LSHIFT RAW, \ save length of name field
   R> ['] .NAME-LABEL TO-ASMOUT      \ output label
   HERE GET-CURRENT REL! ;           \ update CURRENT word list


\ Exceptions #2

VARIABLE HANDLER  0 ' HANDLER >BODY !
: CATCH
   SP@ -CELL STACK-DIRECTION * +  >R \ push data stack pointer
   HANDLER @ >R                      \ push pointer to last frame
   SAVE-INPUT>R                      \ push current input source
   RP@ HANDLER !                     \ set pointer to current frame
   EXECUTE                           \ execute guarded word
   R> BEGIN  ?DUP WHILE              \ pop input source;
     R> DROP  1-                     \ can't use a DO loop as that would
   REPEAT                            \ interfere with the return stack
   R> HANDLER !                      \ reset pointer to previous frame
   R> DROP                           \ discard saved stack pointer
   0 ;                               \ leave OK flag


\ Interpreter #4

: FOREIGN?   ( wid -- f )   2 CELLS + @  1023 > ;
: LOCAL?   ( wid xt n -- f )
   NIP  1 <> IF                      \ is the word non-immediate?
      STATE @                        \ if so, if we are compiling,
      GET-CURRENT FOREIGN?  AND IF   \ and CURRENT is foreign,
         GET-CURRENT =               \ word must be in CURRENT to be compiled
         EXIT
      THEN
   THEN
   FOREIGN? INVERT ;                 \ otherwise word must be native
: NON-META?   ( wid xt n -- f )
   NIP  1 <>  STATE @  AND IF        \ if we are compiling a word,
      DROP  TRUE                     \ allow any word;
   ELSE
      FOREIGN? INVERT                \ to execute, word must be native
   THEN ;
CREATE 'SELECTOR  ' LOCAL?  DUP RAW-REL,  .LINK
: INTERPRET
   BEGIN  BL WORD  DUP C@ WHILE      \ while text in input stream
      'SELECTOR REL@ SELECT          \ search for word
      DUP IF                         \ if word found in dictionary
         STATE @ 0= IF               \ if interpreting, execute it
            DROP                     \ drop found flag
            DUP >INFO @ COMPILING-BIT AND
            IF  -14 THROW  THEN
            EXECUTE
         ELSE
            0> IF                    \ if immediate, execute compile method
               >COMPILE REL@ EXECUTE
            ELSE
               CURRENT-COMPILE,      \ if non-immediate, compile it
            THEN
         THEN
      ELSE                           \ if word is not found
         DROP                        \ drop found flag
         NUMBER                      \ try getting a number
         STATE @ IF                  \ compile if STATE is non-zero
            CURRENT-LITERAL          \ compile single no./LS word
         THEN
      THEN
   REPEAT DROP ;                     \ get rid of input address

: EVALUATE   SAVE-INPUT>R  -1 TO SOURCE-ID  #EVALUAND !  EVALUAND !  0 >IN !
   INTERPRET  R>RESTORE-INPUT ;

: REFILL   ( -- f )
   CASE SOURCE-ID                    \ switch on SOURCE-ID
      0 OF                           \ if user input device
         TIB 80 ACCEPT               \ get a line of text to TIB
         #TIB !  0 >IN !  TRUE
      ENDOF
      -1 OF  FALSE  ENDOF            \ if a string, return false
      >R                             \ save switch
      FIB /FILE-BUFFER R@ READ-LINE  \ else read a line from file
      ABORT" file read error during REFILL"
                                     \ if an exception occurred, abort
      SWAP #FIB !  0 >IN !           \ set no. of chars in line
      R>                             \ restore switch
   ENDCASE ;

: ?STACK   DEPTH 0< ABORT" stack underflow" ;
: REPL
   POSTPONE [
   0 TO SOURCE-ID
   BEGIN  CR REFILL WHILE
      INTERPRET  ?STACK  STATE @ 0= IF  ." ok"  THEN
   REPEAT
   TRUE ABORT" parse area empty" ;
: HANDLE-ERROR ( n -- )
   CASE
      -1 OF  ( ABORT )  ENDOF
      -2 OF  'THROWN @ COUNT TYPE  ENDOF
      -9 OF   -9 HALT  ENDOF
      -10 OF  ." division by zero"  ENDOF
      -11 OF  ." quotient too large"  ENDOF
      -13 OF  'THROWN @ COUNT TYPE  ."  ?"  ENDOF
      -14 OF  ." compilation only"  ENDOF
      -20 OF  ." write to a read-only location"  ENDOF
      -23 OF  -23 HALT  ENDOF
      -56 OF  ( QUIT )  ENDOF
      -512 OF  ." unknown option " 'THROWN @ COUNT TYPE  CR  1 HALT  ENDOF
      ." exception " DUP . ." raised"
   ENDCASE ;
: (QUIT)
   BEGIN
      R0 RP!
      ['] REPL CATCH                 \ cannot return normally
      DUP HANDLE-ERROR
      -56 <> IF  S0 SP!  THEN
   AGAIN ;


\ Tools

: [ELSE] ( -- )
   1 BEGIN                                   \ level
      BEGIN BL WORD COUNT DUP WHILE          \ level adr len
            2DUP S" [IF]" COMPARE 0= IF      \ level adr len
               2DROP 1+                      \ level'
            ELSE                             \ level adr len
               2DUP S" [ELSE]" COMPARE 0= IF \ level adr len
                  2DROP 1- DUP IF 1+ THEN    \ level'
               ELSE                          \ level adr len
                  S" [THEN]" COMPARE 0= IF   \ level
                     1-                      \ level'
                  THEN
               THEN
            THEN ?DUP 0= IF EXIT THEN        \ level'
      REPEAT 2DROP                           \ level
   REFILL 0= UNTIL                           \ level
   DROP ; IMMEDIATE
: [IF] ( flag -- )
   0= IF POSTPONE [ELSE] THEN ; IMMEDIATE
: [THEN] ( -- ) ; IMMEDIATE

: DEFINED?   FIND NIP 0<> ;
: [DEFINED]   BL WORD DEFINED? ; IMMEDIATE
: [UNDEFINED]   POSTPONE [DEFINED] INVERT ; IMMEDIATE


\ Compiler #4

: COLON   HEADER  TRUE SMUDGE  LINK,  ] ;
: :   BL WORD  COLON ;
: CURRENT?   ( wid xt n -- f )   2DROP  GET-CURRENT = ;
: PROVIDED?  ['] CURRENT? SELECT NIP ;
: [PROVIDED]   BL WORD PROVIDED? ; IMMEDIATE
: PROVIDE:
   BL WORD  DUP PROVIDED? IF
      DROP
      POSTPONE [ELSE]
   ELSE
      COLON
   THEN ;
: ;   UNLINK,  POSTPONE [  FALSE SMUDGE ; IMMEDIATE COMPILING
: :NONAME   ALIGN  0 ,  HERE  DUP NONAME .LABEL-DEF  LINK,  ] ;
: ;IMMEDIATE   POSTPONE ;  SET-IMMEDIATE
   DUP  LAST >NAME  .COMPILE-METHOD
   LAST >COMPILE REL! ; IMMEDIATE COMPILING


\ Miscellaneous

: (
   BEGIN
      [CHAR] ) PARSE 2DROP           \ parse up to ) or end of area
      SOURCE-ID 1+  2 U< IF          \ exit if not reading from file
         EXIT
      THEN
      >IN @ IF                       \ was parse area empty?
         SOURCE DROP >IN @ 1- CHARS +  C@ [CHAR] ) <>
                                     \ if not, was last character )?
      ELSE
         TRUE                        \ if empty we must refill
      THEN
      WHILE                          \ if parse area empty or no )
      REFILL 0=                      \ found, refill and parse again
   UNTIL THEN ; IMMEDIATE

: \   SOURCE NIP >IN ! ; IMMEDIATE
: ?   @ . ;
: .S   ?STACK  DEPTH ?DUP IF  1- 0 SWAP DO  I PICK .  -1 +LOOP
   ELSE ." stack empty "  THEN ;


\ Mass storage input/output #4

: INCLUDE-FILE   ( i*x fid -- j*x )
   SAVE-INPUT>R                      \ save current input source
   TO SOURCE-ID                      \ set up new input source
   ALLOCATE-BUFFER IF                \ allocate new file buffer
      SOURCE-ID CLOSE-FILE
      TRUE ABORT" no more file buffers"
   THEN
   TO FIB
   REFILL DUP IF                     \ check for #! line at start of file
      #FIB @ 1 > IF                  \ if we have at least 2 characters
         FIB C@  [CHAR] # =
         FIB 1+ C@  [CHAR] ! =
         AND  IF                     \ and the first two are `#!'
            DROP  REFILL             \ then skip the line
         THEN
      THEN
   THEN
   BEGIN  WHILE                      \ interpret the file
      ['] INTERPRET CATCH ?DUP IF    \ close the file if an exception is
         SOURCE-ID CLOSE-FILE DROP   \ generated, then pass the exception on
         FREE-BUFFER DROP            \ having freed the buffer
         THROW
      THEN
      REFILL
   REPEAT
   FREE-BUFFER ABORT" no file buffer to free"
                                     \ free the file buffer
   R>RESTORE-INPUT ;                 \ restore the input source
: INCLUDED   ( i*x c-addr u -- j*x )
   2DUP  R/O OPEN-FILE IF            \ open file; if error,
      DROP                           \ get rid of bad fid
      \ TYPE FIXME: include file name in error message
      TRUE ABORT" file can't be INCLUDED" \ abort with error message
   THEN
   >R                                \ save fid
   2DROP                             \ drop c-addr u
   R@ INCLUDE-FILE                   \ include the file
   R> CLOSE-FILE                     \ close the file; if error,
   ABORT" error after INCLUDEing" ;  \ give error message and abort
: INCLUDE"   ( file )   [CHAR] " WORD COUNT  INCLUDED ;


\ Compiler #5

: '   BL WORD FIND  0= IF  UNDEFINED  THEN ;
: [']   '   DUP >NAME .PUSHRELI-SYMBOL  PUSHREL, ; IMMEDIATE COMPILING


\ Defining

: CREATE   BL WORD HEADER  CREATE,  ALIGN  LAST .BODY-LABEL-DEF ;
: DOES>   LAST POSTPONE RELATIVE-LITERAL  POSTPONE (DOES>)  UNLINK,  ALIGN
   HERE LAST TUCK - CELL/  SWAP  DUP >NAME ['] .DOES-LABEL TO-ASMOUT  >INFO
   DUP @ $FFFF INVERT AND ROT OR  SWAP !  DOES-LINK, ; IMMEDIATE COMPILING

: VARIABLE   CREATE  1 ALLOT-CELLS ;
: CONSTANT   BL WORD HEADER  LINK,  POSTPONE LITERAL  UNLINK, ;
: VALUE   CREATE  ,  DOES>  @ ;
: .BODY-LITERAL   ." pushreli " .NAME ." _body" CR ;
: BODY-LITERAL
   DUP FIND  0= IF  UNDEFINED  THEN
   >BODY  PUSHREL,
   ['] .BODY-LITERAL  TO-ASMOUT ;
: TO   ' >BODY ! ;
   :NONAME   BL WORD  BODY-LITERAL  POSTPONE ! ;IMMEDIATE

: .DEFER-ADDRESS   ." .word " .NAME ." _defer - ." CR ;
: DEFER   CREATE  HERE  ['] ABORT >REL RAW,  LAST >NAME ['] .DEFER-ADDRESS TO-ASMOUT  DOES>  REL@ EXECUTE ;
: ACTION-OF   ' DEFER@ ;
   :NONAME   POSTPONE [']  POSTPONE DEFER@ ;IMMEDIATE
: .DEFER-LABEL   ." .set " .NAME ." _defer, "
   DUP >INFO CELL 1- + C@ IF  >NAME .NAME  ELSE NONAME .LABEL  THEN  CR ;
: .DEFER-ABORT   ." .set " .NAME ." _defer, ABORT" CR ;
: IS   '  2DUP >NAME ['] .DEFER-LABEL TO-ASMOUT  DEFER! ;
   :NONAME   POSTPONE [']  POSTPONE DEFER! ;IMMEDIATE


\ Word lists

: DICTIONARY   CREATE  HERE CELL+ ,  ALLOT  DOES>  TO DP ;
: ROOT   ROOTDP TO DP ;

CREATE CHAIN  HERE BACKWARD .LABEL-DEF  0 ,
( A wordlist has the following structure:

  Head of list         relative link to most recently defined word
  Link field           relative link to next wordlist in CHAIN
  Info field           bit 10 is FOREIGN flag
)
: WORDLIST   ALIGN HERE  0 RAW,
   HERE  CHAIN  DUP REL@ RAW-REL,  0 .WORD ( FIXME: chain to previous wordlist )  REL!  0 , ;
: VOCABULARY   WORDLIST  CREATE  REL,  DOES>
   #ORDER @ 0= IF  1 #ORDER +!  THEN  REL@ CONTEXT ! ;
HERE BACKWARD .LABEL-DEF  ' .FORTH-ADDRESS TO-ASMOUT
VOCABULARY FORTH
: FORTH-WORDLIST   ['] FORTH >BODY REL@ ;
: ALSO   CONTEXT  DUP CELL+  #ORDER @ CELLS  MOVE  1 #ORDER +! ;
: ONLY   FORTH  1 #ORDER ! ;
: FOREIGN   CONTEXT @  2 CELLS +  DUP @ 1024 OR  SWAP ! ;
: NATIVE   CONTEXT @  2 CELLS +  DUP @ 1023 AND  SWAP ! ;
: SET-ORDER   DUP -1 = IF  ONLY  ELSE  DUP #ORDER !  CELLS  CONTEXT TUCK +
   SWAP ?DO  I !  CELL +LOOP  THEN ;
: PREVIOUS   GET-ORDER  DUP 0> IF  NIP 1-  THEN  SET-ORDER ;
: ORDER   ." CONTEXT: "  GET-ORDER  0 ?DO  H.  LOOP  CR ." CURRENT: "
   GET-CURRENT H. ;

VARIABLE CURSORX   \ cursor x position during WORDS
: ADVANCE   ( +n -- )   CURSORX +! ;
: WRAP?   ( -- f )   CURSORX @ + WIDTH < INVERT ;
: NEWLINE   0 CURSORX !  CR ;
3 CONSTANT GAP
: WORDLIST-WORDS   ( wid -- )
   NEWLINE                           \ start listing on a new line
   BEGIN  REL@ ?DUP WHILE            \ for each word in the chain
      DUP >NAME COUNT                \ get the name
      DUP WRAP? IF  NEWLINE  THEN    \ new line if necessary
      DUP ADVANCE                    \ advance the cursor
      TYPE                           \ type the name
      GAP WRAP? IF                   \ leave a gap or move to a new
         NEWLINE                     \ line
      ELSE
         GAP  DUP SPACES  ADVANCE
      THEN
      >LINK                          \ get link to next word
   REPEAT
   CURSORX @ IF  NEWLINE  THEN ;     \ ensure we're on a new line
: WORDS   CONTEXT @  WORDLIST-WORDS ;
: ALL-WORDS   GET-ORDER 0 ?DO  WORDLIST-WORDS  LOOP ;


\ Exceptions #3

: (THROW)
   ?DUP IF                           \ if flag is true
      HANDLER @ ?DUP IF              \ and there's a frame to pop
         RP!                         \ set return stack to frame
         R>RESTORE-INPUT             \ restore input source
         R> HANDLER !                \ set pointer to next frame
         R> SWAP >R                  \ keep exception number
         SP!                         \ restore data stack
         R>                          \ restore exception number
      ELSE                           \ if no frame,
         ERROR-PREFIX                \ print any message
         DUP HANDLE-ERROR CR
         HALT                        \ and halt
      THEN
   THEN ;


\ FIXME: use curses instead.
: AT-XY
   27 EMIT  [CHAR] [ EMIT  SWAP 0 .R  [CHAR] ; EMIT  0 .R  [CHAR] H EMIT ;

INCLUDE" compiler-asm.fs"


\ Command-line argument interface
\ (Design copied from GForth)

VARIABLE ARGC

: INITIALIZE-ARGS   TOTAL-ARGS ARGC ! ;

: ARG   TOTAL-ARGS ARGC @ -  +  ABSOLUTE-ARG ;
: SHIFT-ARGS   ARGC @ 1-  0 MAX  ARGC ! ;
: NEXT-ARG   0 ARG  SHIFT-ARGS ;


\ Initialisation and version number

: VERSION   S" @VERSION@" ;
INCLUDE" platform.fs"

: HELP
   ." Usage: "  "PROGRAM-NAME REL@ COUNT TYPE  ."  [OPTION...] [FILENAME...]" CR
   CR
   ." Run @PACKAGE_NAME@." CR
   CR
   ." --interact       enter interactive loop after evaluating" CR
   ."                  command-line arguments" CR
   ." --evaluate TEXT  evaluate the given text" CR
   ." --help           display this help message and exit" CR
   ." --version        display version information and exit" CR
   ." FILE             evaluate FILE" CR
   CR
   ." Report bugs to @PACKAGE_BUGREPORT@." CR ;

: BANNER
   ." @PACKAGE_NAME@ v" VERSION TYPE ."  (platform: " "PLATFORM TYPE ." )"
   CR ." (c) Reuben Thomas 1991-2021" CR ;

FALSE VALUE INTERACT?
: DO-START-OPTIONS
   ARGC @ IF
      HERE "PROGRAM-NAME REL!        \ update "PROGRAM-NAME
      NEXT-ARG ",                    \ save new name
   THEN
   ARGC @ IF
      BEGIN  NEXT-ARG OVER WHILE
         OVER C@  [CHAR] - =  IF     \ process option
            "CASE
               S" --help"     "OF  HELP BYE           "ENDOF
               S" --version"  "OF  BANNER BYE         "ENDOF
               S" --evaluate" "OF  NEXT-ARG EVALUATE  "ENDOF
               S" --interact" "OF  TRUE TO INTERACT?  "ENDOF
               HERE 'THROWN !  ",  -512 THROW
            "ENDCASE
         ELSE                        \ or interpret file
            \ FIXME: install CATCH handler, and if INTERACT? is true, even
            \ if case of error, respect it
            INCLUDED
         THEN
      REPEAT
      2DROP                          \ drop 0 0 from NEXT-ARG
      INTERACT? INVERT IF  BYE  THEN
   ELSE
      BANNER
   THEN
   (QUIT) ;

: START   ( here -- )
   \ Assume that we were called by a call instruction at 'FORTH, and
   \ use our return address to calculate the new value of 'FORTH.
   R> CELL-  TO 'FORTH
   [ HERE  .ASM[ pushreli END_OF_IMAGE]  0 RAW,  DUP ] \ value of HERE
   ROOTDP !                          \ initialize dictionary pointer
   [ ' (THROW) ] RELATIVE-LITERAL 'THROW!
                                     \ set 'THROW
   0 HANDLER !                       \ reset HANDLER
   0 FILE-BUFFER# !                  \ reset FILE-BUFFER#
   ROOT                              \ use ROOT dictionary
   ONLY FORTH DEFINITIONS            \ minimal word list
   DECIMAL                           \ numbers treated as base 10
   INITIALIZE-ARGS
   INITIALIZE-TERMINAL
   DO-START-OPTIONS ;                \ process command-line args

ALIGN
.ASM[ END_OF_IMAGE:]
HERE >-<  OP_PUSHRELI OR  SWAP ! \ FIXME: add !OFFSET
