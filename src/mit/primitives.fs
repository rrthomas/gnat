CR .( Required primitives )

ALSO ASSEMBLER \ For INLINE

\ Stack primitives

1 0 PRIMITIVE DROP
BLIT_1 BPOP
END-PRIMITIVE

1 1 PRIMITIVE PICK
BDUP
END-PRIMITIVE

2 2 PRIMITIVE SWAP
BLIT_0 BSWAP
END-PRIMITIVE

0 1 PRIMITIVE CELL
] 4 [
END-PRIMITIVE

0 1 PRIMITIVE -CELL
] -4 [
END-PRIMITIVE


\ Memory primitives

1 1 PRIMITIVE @
BLIT_2 BLOAD \ FIXME: constant!
END-PRIMITIVE

2 0 PRIMITIVE !
BLIT_2 BSTORE
END-PRIMITIVE

1 1 PRIMITIVE C@
BLIT_0 BLOAD
END-PRIMITIVE

2 0 PRIMITIVE C!
BLIT_0 BSTORE
END-PRIMITIVE


\ Arithmetic and logical primitives

2 1 PRIMITIVE +
BADD
END-PRIMITIVE

2 1 PRIMITIVE -
BNEGATE BADD
END-PRIMITIVE

1 1 PRIMITIVE NEGATE
BNEGATE
END-PRIMITIVE

2 1 PRIMITIVE *
BMUL
END-PRIMITIVE

\ FIXME: check for division by zero
2 2 PRIMITIVE U/MOD
BUDIVMOD
BLIT_0 BSWAP
END-PRIMITIVE

2 2 PRIMITIVE S/REM
BDIVMOD
BLIT_0 BSWAP
END-PRIMITIVE

2 1 PRIMITIVE =
BEQ
BNEGATE
END-PRIMITIVE

2 1 PRIMITIVE <
BLT
BNEGATE
END-PRIMITIVE

2 1 PRIMITIVE U<
BULT
BNEGATE
END-PRIMITIVE

2 1 PRIMITIVE AND
BAND
END-PRIMITIVE

2 1 PRIMITIVE OR
BOR
END-PRIMITIVE

2 1 PRIMITIVE XOR
BXOR
END-PRIMITIVE

1 1 PRIMITIVE INVERT
BNOT
END-PRIMITIVE

2 1 PRIMITIVE LSHIFT
BLSHIFT
END-PRIMITIVE

2 1 PRIMITIVE RSHIFT
BRSHIFT
END-PRIMITIVE


\ System primitives

1 0 $2 LIBC-PRIMITIVE HALT


\ Control primitives

\ Must NOT be inline, as it needs caller's PC!
\ FIXME: use LIT_PC_REL
CODE (CREATE)
BLIT_0 BSWAP
BBRANCH
END-CODE

INCLUDE" bracket-does.fs"


\ Stack management

\ FIXME: Make this a small constant!
VARIABLE PRIMITIVE-RP

\ FIXME: Make this a small constant!
VARIABLE RP
\ FIXME: >R and R> must be defined as CODE words, because they are needed by
\ LINK, and UNLINK,
1 0 PRIMITIVE >R
' RP >BODY <'FORTH LITERAL,
BLIT_0 BDUP
BLIT_2 BLOAD \ FIXME: constant!
-4 LITERAL, BADD \ FIXME: target -CELL, not -4
BLIT_0 BDUP
BLIT_1 BSWAP
BLIT_2 BSTORE \ FIXME: constant!
BLIT_2 BSTORE \ FIXME: constant!
END-PRIMITIVE
0 INLINE \ Prevent inlining: it's too long to go at the start of each word!

0 1 PRIMITIVE R>
' RP >BODY <'FORTH LITERAL,
BLIT_0 BDUP
BLIT_2 BLOAD \ FIXME: constant!
BLIT_0 BDUP
4 LITERAL, BADD \ FIXME: target CELL, not 4
BLIT_0 BSWAP
BLIT_1 BSWAP
BLIT_2 BSTORE \ FIXME: constant!
BLIT_2 BLOAD \ FIXME: constant!
END-PRIMITIVE
0 INLINE \ Prevent inlining: it's too long to go at the start of each word!

0 1 PRIMITIVE R@
' RP >BODY <'FORTH LITERAL,
BLIT_2 BLOAD \ FIXME: constant!
BLIT_2 BLOAD \ FIXME: constant!
END-PRIMITIVE

0 1 PRIMITIVE RP@
' RP >BODY <'FORTH LITERAL,
BLIT_2 BLOAD \ FIXME: constant!
END-PRIMITIVE

\ FIXME: -9 THROW if RP is out of range
\ Must be a primitive as it would mess up its own return
1 0 PRIMITIVE RP!
' RP >BODY <'FORTH LITERAL,
BLIT_2 BSTORE \ FIXME: constant!
END-PRIMITIVE


0 NATIVE-POINTER-CELLS $0 LIBMIT-PRIMITIVE MIT_CURRENT_STATE
2 NATIVE-POINTER-CELLS $1 LIBMIT-PRIMITIVE NATIVE_ADDRESS_OF_RANGE
NATIVE-POINTER-CELLS 1 $13 LIBMIT-PRIMITIVE GET_STACK_DEPTH
1 NATIVE-POINTER-CELLS + 0 $14 LIBMIT-PRIMITIVE SET_STACK_DEPTH

\ Stack management primitives

0 0 PRIMITIVE SP@
BPUSH_STACK_DEPTH
BLIT_2 BLSHIFT \ FIXME constant!
END-PRIMITIVE

1 0 PRIMITIVE SP!
BLIT_2 BRSHIFT BNOT \ FIXME constant!
BPUSH_STACK_DEPTH BADD BPOP
END-PRIMITIVE

\ FIXME: Put in better order; must be defined after bracket-create is included because of use of VALUE
1024 1024 * VALUE MEMORY-SIZE \ FIXME: command-line parameter

\ FIXME: Make these optional in pForth (highlevel.fs does not need them)
4096 CONSTANT STACK-CELLS
4096 CONSTANT RETURN-STACK-CELLS

0 CONSTANT S0
0 VALUE R0


PREVIOUS
