%
% Gnat
%
% Reuben Thomas   25/4-16/5/97
%


\documentclass[english]{article}
\usepackage{literate,reggram,babel}


\begin{document}

\title{Gnat}
\author{Reuben Thomas}
\date{16th May 1997}
\maketitle



Gnat is a simple language.

\begin{history}
0.00 & 25&Apr&97 &
Skeleton copied from Mite. \\
0.01 & 28&Apr&97 &
Lexical scanner written. \\
0.02 & 07&May&97 &
Parser written. \\
0.03 & 10&May&97 &
Parser linked to lexical scanner. \\
0.04 & 14&May&97 &
Parse tree printer written. \\
0.05 & 15&May&97 &
Parser made to return parse tree and linked to parse tree printer. \\
0.06 & 16&May&97 &
Parse tree printer modified to display the structure of the parse tree. \\
\end{history}



\section{General}

A few macros which are of general use are provided in ¦gnat.h¦. They are too
general to go in a more specific header, and too few to warrant a header of
their own.

Definitions for true and false booleans; since many headers define them, we
undefine them first:

@d Truth values
@{
#undef FALSE
#undef TRUE
#define FALSE 0
#define TRUE 1
@| FALSE TRUE @}

\cont A macro which prints a debugging message followed by a newline if the
variable ¦yydebug¦ is non-zero:

@d Debugging message
@{#define DEBUG(s) if (yydebug) { fprintf(stderr, s); putc('\n', stderr); }
@| DEBUG @}



\section{The lexical scanner}

Lexical analysis is performed by a Flex scanner.


\subsection{Preliminaries}

The header ¦gnattab.h¦ contains the codes for the return types of ¦yylex()¦
generated by Bison for the parser (see section~\ref{parser}).

@o gnatlex.l
@{
%{
#include <except.h>
#include "gnat.h"
#include "gnattab.h"
%}
@}

\cont Start conditions are nested so that comments can occur between
adjcacent \nont{string} tokens. The stack also takes care of comment nesting.

@o gnatlex.l
@{%option stack nounput noyy_top_state
@}

\cont The start conditions ¦Comment¦ and ¦String¦ are active while scanning
comments and strings, and the condition ¦String_End¦ just after a string has
been scanned.

@o gnatlex.l
@{%x Comment String String_End
@| Comment String String_End @}

\cont ¦Symbol¦ represents the non-terminal \nont{symbol} in Gnat's grammar.
For safety, all the symbols are escaped.

@o gnatlex.l
@{Symbol [\!\#\$\%\&\'\*\+\-\/\:\<\=\>\?\@@\\\^\_\`\|\~]
@| Symbol @}

\cont ¦yystring¦ is the buffer for \nont{string} tokens being scanned in;
\nont{yystringp} points to where the next character will go.

@o gnatlex.l
@{
%%
%{
#include <stdlib.h>
#include <string.h>
#include <except.h>
#include "gnat.h"

char yystring[16385];
char *yystringp= yystring;

char *keyword[]= { "#", "$", "$$", "$=", ":", ":=", "=>", "do", "else",
"false", "if", "null", "then", "true", "while", "|=" };
#define KEYWORDS (sizeof(keyword) / sizeof(keyword[0]))

int token[]= { '#', '$', TOK_SLICE, TOK_KEY, ':', TOK_ASS, TOK_FUNC, TOK_DO,
TOK_ELSE, TOK_FALSE, TOK_IF, TOK_NULL, TOK_THEN, TOK_TRUE, TOK_WHILE, TOK_ORD
};

int bstrcmp(const void *s, const void *t);
%}
@| yystring yystringp keyword KEYWORDS token bstrcmp @}

\cont ¦bstrcmp()¦ is just a veneer to ¦strcmp()¦ for use with ¦bsearch()¦.


\subsection{Rules}

\subsubsection{Comments}

A comment can start either in the ¦INITIAL¦ condition, after a string, or
within another comment. When a comment is found the current start condition
is saved to ensure that nested comments and adjacent \nont{string} tokens are
scanned properly.

@o gnatlex.l
@{
<Comment,String_End,INITIAL>"//"    {
    yy_push_state(Comment);
    }
@}

Once within the comment, we look for the delimiter and exit to the previous
start condition.

@o gnatlex.l
@{
<Comment>{
    [^\\/]*
    \\[^\\/]*
    \\\\    {
        yy_pop_state();
        }
}
@}

\subsubsection{Integers}

@o gnatlex.l
@{
_?[[:digit:]][[:alnum:]]*("_"[[:digit:]]+)? {
    int neg= FALSE;
    int base= 10;
    long num;
    char *nump, *basep;
@| neg base num nump basep @}

\cont This rule scans \nont{int}s. When an \nont{int} is found the first
character is checked; if it is an underscore (unary minus) then ¦neg¦ is set
to ¦TRUE¦.

@o gnatlex.l
@{
    nump= yytext;
    if (*nump == '_') {
        neg= TRUE;
        nump++;
    }
@}

\cont Next the base, if any, is converted to a number and range checked; if
there is no base then ¦base¦ defaults to 10.

@o gnatlex.l
@{
    if ((basep= strchr(nump, '_'))) {
        *basep++= '\0';
        base= atoi(basep);
        if (base < 2 || base > 36) except(EXC_FATLINE, "illegal base\n");
    }
@}

\cont Lastly the number is converted using ¦strtol()¦ and returned.

@o gnatlex.l
@{
    num= strtol(nump, NULL, base);
    if (neg) num= -num;

    yylval.num= num;  return TOK_INT;
    }
@}

\subsubsection{Identifiers}

@o gnatlex.l
@{
[[:alpha:]][_[:alnum:]]*|{Symbol}+  {
    char **tok= bsearch(&yytext, keyword, KEYWORDS, sizeof(char *), bstrcmp);

    DEBUG(yytext);
    if (tok) return token[tok - keyword];
    else {
        yylval.string= (char *)exc_malloc(EXC_FATALN, strlen(yytext));
        strcpy(yylval.string, yytext);
        return TOK_ID;
    }
    }
@}

\cont This rule scans \nont{id}s. If the \nont{id} is a reserved word, the
corresponding token is returned; otherwise the string and ¦TOK_ID¦ is
returned.

\subsubsection{Strings}

A string starts whenever we find a quote and are not already scanning a
string. We rely on ¦yystringp¦ having been initialised to ¦yystring¦.

@o gnatlex.l
@{
<String_End,INITIAL>\"  {
    BEGIN(String);
    }
@}

When at the end of a string and we find a character that is not a quote the
current \nont{strings} token has finished and we return the amalgamated
\nont{string} and return to the ¦INITIAL¦ state. ¦yystringp¦ is reset.

@o gnatlex.l
@{
<String_End>.|\n    {
    *yystringp= '\0';
    yylval.string= (char *)exc_malloc(EXC_FATALN, yystringp - yystring + 1);
    strcpy(yylval.string, yystring);

    yystringp= yystring;
    yyless(0);
    BEGIN(INITIAL);

    return TOK_STRING;
    }
@}

Now the rules for scanning strings. When an unescaped quote is found the
string has ended, and we enter the special state ¦String_End¦ in case the
next token is also a \nont{string}.

@o gnatlex.l
@{
<String>{
    \"  {
        BEGIN(String_End);
        }
@}

Control characters are not allowed in strings.

@o gnatlex.l
@{
    [\x00-\x1f]+    {
        except(EXC_FATAL, "control character in string");
        }
@}

Decimal escapes are range-checked and converted.

@o gnatlex.l
@{
    \\d[[:digit:]]{1,3}   {
        int res;

        sscanf(yytext + 2, "%d", &res);
        if (res > 0xff)
            except(EXC_FATAL, "decimal escape sequence out of bounds");
        *yystringp++= res;
        }
@}

Hex escapes do not even need to be range-checked, but are just converted.

@o gnatlex.l
@{
    \\h[[:xdigit:]]{1,2}  {
        int res;

        sscanf(yytext + 2, "%x", &res);
        *yystringp++= res;
        }
@}

The special escape sequences are dealt with easily.

@o gnatlex.l
@{
    \\n  *yystringp++= '\n';
    \\t  *yystringp++= '\t';
    \\\" *yystringp++= '\"';
    \\\\ *yystringp++= '\\';
@}

Any other escape sequence is illegal.

@o gnatlex.l
@{
    \\.  except(EXC_FATAL, "illegal escape sequence %s\n", yytext);
@}

All other characters are appended to the string.

@o gnatlex.l
@{
    [^\\\"\x00-\x1f]+    {
        char *yptr= yytext;

        while (*yptr)
            *yystringp++= *yptr++;
        }
}
@}

\subsubsection{White space}

@o gnatlex.l
@{<*>[ \t\n]+    /* empty */
@}

\cont This rule discards white space tokens; it comes at the end so as not to
interfere with string parsing.

\subsubsection{Characters}

@o gnatlex.l
@{
[[:print:]] {
    return *yytext;
    }
@}

\cont This rule scans \nont{char}s. It comes last of all the rules that apply
in the ¦INITIAL¦ condition so that it is only used when no other rule
matches.


\subsection{Support functions}

¦yyfrom()¦ is provided to allow the current input stream to be set. It simply
assigns ¦yyin¦ to the ¦FILE¦ pointer passed to it:

@o gnatlex.l
@{
%%
void yyfrom(FILE *file)
{
    yyin= file;
}
@}

\cont ¦bstrcmp()¦ is just a veneer to ¦strcmp()¦ for use with ¦bsearch()¦.

@o gnatlex.l
@{
int bstrcmp(const void *s, const void *t)
{
    return strcmp(*(char **)s, *(char **)t);
}
@| bstrcmp @}



\section{The parser} \label{parser}

Parsing is performed by a Bison parser. The parse results in a parse tree
consisting of nodes which are labelled with a type and contain sub-nodes, or
leaf values.


\subsection{Preliminaries}

A simple structure, ¦parse_node¦, is defined for the parse tree nodes. It has
a variable number of fields; the first, ¦type¦, holds the token type
corresponding to the type of node, and the rest point to the sub-nodes.
Hence, rather than allocating ¦parse_node¦s, the correct amount of space for
each node is allocated using the formula \mbox{\conc{sizeof(int) +
sizeof(void *) * }\textit{sub-nodes}}. The macro ¦SUBNODE()¦ provides a
convenient way of accessing sub-nodes.

@d Parse tree node structure
@{
typedef struct { int type; void *subnode; } parse_node;
#define SUBNODE(p, n) (*(parse_node **)(&(p)->subnode + (n)))
@| parse_node @}

\cont The reason that the pointers are ¦void *¦ rather than ¦parse_node *¦ is
that at the leaves of the three they point to the semantic values of the
terminal tokens.

A parser without global state is generated, and the number of expected
shift-reduce conflicts is specified; it is large because of the rules for
application.

The function ¦node()¦, which creates parse tree nodes, is also declared:

@d Create a parse tree node
@{parse_node *node(int subnodes, ...);
@| node @}

The Bison file must first include necessary headers and declarations:

@o gnattab.y
@{
%{
#include <stdarg.h>
#include <string.h>
#include <except.h>
#include "gnat.h"

#define YYERROR_VERBOSE
#define YYDEBUG 1
int yylex(void);
void yyerror(char *s);
%}

%expect 2
@}


\subsection{Token types}

First the semantic types union:

@o gnattab.y
@{
%union {
    long num;
    char *string;
    parse_node *ptree;
}
@}

\cont The first two types are returned by the lexical scanner, and the third
is that of records in the parse tree.

Next, the token types returned by the lexical scanner:

@o gnattab.y
@{
%token <num> TOK_INT
%token <string> TOK_STRING TOK_ID
%token TOK_NULL TOK_FALSE TOK_TRUE TOK_FUNC TOK_ASS TOK_AND TOK_ORD TOK_KEY
%token TOK_VAL TOK_SLICE TOK_IF TOK_THEN TOK_ELSE TOK_WHILE TOK_DO
@| TOK_INT TOK_STRING TOK_ID TOK_NULL TOK_FALSE TOK_TRUE TOK_FUNC TOK_ASS
TOK_AND TOK_ORD TOK_KEY TOK_VAL TOK_SLICE TOK_IF TOK_THEN TOK_ELSE TOK_WHILE
TOK_DO @}

\cont The terminal symbols do not have semantic values.

The types of the non-terminals are declared:

@o gnattab.y
@{
%type <ptree> exps exp block decls decl asses ass if while
%type <ptree> app func val slice sel list abs_list conc_list mod_list elem
%type <ptree> atom count var
@| exps exp block decls decl asses ass if while app func val slice sel list
abs_list conc_list mod_list elem atom count var @}

\cont Finally, a terminal token is declared for the non-terminals which
contain more than one component and do not already have a terminal with the
same name. This is a convenient way of generating label codes for the parse
tree.

@o gnattab.y
@{
%token TOK_EXPS TOK_BLOCK TOK_DECLS TOK_ASSES
%token TOK_APP TOK_ABS_LIST TOK_CONC_LIST TOK_MOD_LIST
%token TOK_COUNT TOK_VAR
%%
@| TOK_EXPS TOK_BLOCK TOK_DECLS TOK_ASSES TOK_APP TOK_ABS_LIST TOK_CONC_LIST
TOK_MOD_LIST TOK_COUNT TOK_VAR @}


\subsection{Grammar}

The rules for the grammar are given from the top down, in accordance with its
presentation. There is no rule for \nont{prog}, as a \nont{prog} must be an
\nont{exps}.

The parse tree nodes are labelled with terminal tokens. Most rules in the
parser cause the components parsed by that rule to be assembled into a node
which is labelled with a terminal corresponding to the non-terminal which is
being parsed. Some rules do not do this as the additional wrapping up only
bloats the tree and adds no useful information.

A special convention is used for lists such as \nont{exps}, \nont{decls} and
\nont{list}s. These are parsed as a linked list of node pairs. In each node
the first sub-node points to the rest of the list or ¦NULL¦, and the second
to a list item.

Note that some terminal tokens, such as ¦TOK_SLICE¦, have two unrelated
meanings, one as a keyword and one as a label in the parse tree.

@O gnattab.y
@{
exps:       exp                 { gnat_program=
                                    $$= node(2, TOK_EXPS, NULL, $1); }
    |       exps ';' exp        { gnat_program=
                                    $$= node(2, TOK_EXPS, $1, $3); }
    ;

exp:        /* empty */         { $$= node(0, TOK_NULL); }
    |       block
    |       asses
    |       if
    |       while
    |       func
    |       app
    ;

block:      '{' exps '}'        { $$= node(2, TOK_BLOCK, NULL, $2); }
    |       '{' TOK_VAL decls ';' exps '}'
                                { $$= node(2, TOK_BLOCK, $3, $5); }
    ;

decls:      decl                { $$= node(2, TOK_DECLS, NULL, $1); }
    |       decls ',' decl      { $$= node(2, TOK_DECLS, $1, $3); }
    ;

decl:       var
    |       asses
    ;

asses:      ass                 { $$= node(2, TOK_ASSES, NULL, $1); }
    |       asses TOK_AND ass   { $$= node(2, TOK_ASSES, $1, $3); }
    ;

ass:        var TOK_ASS exp     { $$= node(2, TOK_ASS, $1, $3); }
    ;

if:         TOK_IF app TOK_THEN exp
                                { $$= node(2, TOK_THEN, $2, $4); }
    |       TOK_IF app TOK_THEN exp TOK_ELSE exp
                                { $$= node(3, TOK_ELSE, $2, $4, $6); }
    ;

while:      TOK_WHILE app TOK_DO exp
                                { $$= node(2, TOK_WHILE, $2, $4); }
    ;

app:        val                 { $$= node(2, TOK_APP, NULL, $1); }
    |       app val             { $$= node(2, TOK_APP, $1, $2); }
    ;

func:       var TOK_FUNC exp    { $$= node(2, TOK_FUNC, $1, $3); }
    ;

val:        slice
    |       sel
    |       list
    |       TOK_NULL            { $$ = node(0, TOK_NULL); }
    ;

slice:      list '$' val        { $$= node(2, '$', $1, $3); }
    |       list TOK_SLICE val  { $$= node(2, TOK_SLICE, $1, $3); }
    ;

sel:        list '.' var        { $$= node(2, '.', $1, $3); }
    |       list ':' val        { $$= node(2, ':', $1, $3); }
    ;

list:       '[' abs_list ']'    { $$= $2; }
    |       '[' conc_list ']'   { $$= $2; }
    |       '[' mod_list ']'    { $$= $2; }
    |       atom
    ;

abs_list:   ass                 { $$= node(2, TOK_ABS_LIST, NULL, $1); }
    |       abs_list ',' ass    { $$= node(2, TOK_ABS_LIST, $1, $3); }
    ;

conc_list:  app                 { $$= node(2, TOK_CONC_LIST, NULL, $1); }
    |       conc_list ',' app   { $$= node(2, TOK_CONC_LIST, $1, $3); }
    ;

mod_list:   elem                { $$= node(2, TOK_MOD_LIST, NULL, $1); }
    |       mod_list ',' elem   { $$= node(2, TOK_MOD_LIST, $1, $3); }
    ;

elem:       app TOK_ORD app     { $$= node(2, TOK_ORD, $1, $3); }
    |       app TOK_KEY app     { $$= node(2, TOK_KEY, $1, $3); }
    ;

atom:       count
    |       var
    |       TOK_FALSE           { $$= node(0, TOK_FALSE); }
    |       TOK_TRUE            { $$= node(0, TOK_TRUE); }
    |       '(' exp ')'         { $$= $2; }
    |       TOK_INT             { $$= node(1, TOK_INT, $1); }
    |       TOK_STRING          { $$= node(1, TOK_STRING, $1); }
    ;

count:      '#' list            { $$= node(1, TOK_COUNT, $2); }
    ;

var:        TOK_ID              { $$= node(1, TOK_VAR, $1); }
    ;
@| exps exp block decls decl asses ass if while app func val slice sel list
abs_list conc_List mod_list elem atom count var @}


\subsection{Support functions}

\subsubsection{Building the parse tree}

¦node()¦ returns a new ¦parse_node¦ containing the arguments passed to it,
which must therefore all fit into a ¦void *¦. The number of sub-nodes is
passed as the first argument.

@o gnattab.y
@{
%%
parse_node *node(int subnodes, ...)
{
    int i;
    va_list ap;
    parse_node *ptr= (parse_node *)exc_malloc(EXC_FATALN,
      sizeof(int) + sizeof(void *) * subnodes);
@| node @}

\cont First the node is allocated, and an exception is raised if it cannot
be.

@o gnattab.y
@{
    va_start(ap, subnodes);
    ptr->type= (int)va_arg(ap, int);
    for (i= 0; i < subnodes; i++)
        SUBNODE(ptr, i)= (parse_node *)va_arg(ap, parse_node *);
    va_end(ap);

    return ptr;
}
@| node @}

\cont Next, the node's fields are filled in and the node is returned.

\subsubsection{Reporting errors}

The usual definition of ¦yyerror()¦:

@o gnattab.y
@{
void yyerror(char *s)
{
    fprintf(stderr, "%s: %s\n", prog_name, s);
}
@}



\section{Parse tree walking}

Routines that walk over the parse tree have a common recursive descent
structure that resembles the grammar.

The macro ¦PTREE_EXCEPTION¦ raises an appropriate exception if an illegal
node is discovered in a parse tree:

@d Raise exception for bad parse tree
@{
#define PTREE_EXCEPTION except(EXC_FATAL, "illegal node in parse tree");
@| PTREE_EXCEPTION @}



\section{Parse tree display}

¦parse_display()¦ prints the parse tree out. This is mainly useful for
debugging; the function also acts as a model for other functions which
operate on the tree. A hierarchy of functions display the parse tree, one for
each terminal token. If an illegal token is found, an exception is raised.
This is a useful debugging aid to help ensure that any transformations
carried out on the tree do the right thing.

\subsection{Support functions and variables}

The display routines allow indenting. The macro ¦PARSE_DISPLAY_TAB¦ hold the
width of the tab:

@d Parse tree display parameters
@{#define PARSE_DISPLAY_TAB 6
@| PARSE_DISPLAY_TAB @}

\cont The variable ¦parse_display_x¦ holds the current cursor position, and
¦parse_display_indent¦ holds the current indentation level;
¦parse_display_bar¦ is an array of characters which give the current
character to be printed at each tab position:

@d Parse tree display parameters
@{
static int parse_display_x= 0;
static int parse_display_indent= 0;
static char parse_display_bar[32];
@| parse_display_x parse_display_indent parse_display_bar @}

\cont The function ¦pprint_header()¦ prints a node header and increments the
level of indentation.

@d Print parse tree node header
@{
void pprint_header(char *s)
{
    pprint("+-%s", s);
    ++parse_display_indent;
    for (; parse_display_x < parse_display_indent * PARSE_DISPLAY_TAB - 2;
          parse_display_x++)
        putchar('-');
}
@| pprint_header @}

\cont ¦pprint_end()¦ decrements the indenting level at the end of a
construct.

@d Finish a parse tree node
@{
void pprint_end(void)
{
    --parse_display_indent;
}
@| pprint_end @}

\cont ¦pprint_bar_on()¦ puts a bar at the indentation level before the
current one.

@d Add a bar
@{
void pprint_bar_on(void)
{
    parse_display_bar[parse_display_indent - 1]= '|';
}
@| pprint_bar_on @}

\cont ¦pprint_bar_off()¦ removes any bar at the indentation level before the
current one.

@d Remove a bar
@{
void pprint_bar_off(void)
{
    parse_display_bar[parse_display_indent - 1]= ' ';
}
@| pprint_bar_off @}

\cont ¦pprint()¦ is the pretty printing function which is used to display the
text. It takes the same arguments as ¦printf()¦, but prints to the current
indenting level. This is done in two stages: first, the arguments are
written to a buffer using ¦vsprintf()¦; then, the string is scanned
and output. Spaces are printed verbatim, newlines are followed by indenting
spaces to the current level of indentation, and white-space-separated tokens
are printed with appropriate wrapping.

Three supplementary functions are used to print newlines, spaces and tokens.
¦pprint_nl()¦ prints a newline is output, then the cursor position is reset
according to ¦parse_display_indent¦ and an appropriate number of spaces and
bars is output. If the parameter ¦hdr¦ is ¦TRUE¦, then no bar is printed,
leaving space for dashes before a header.

@d Pretty print a newline
@{
void pprint_nl(int hdr)
{
    int i;

    putchar('\n');
    parse_display_x= parse_display_indent * PARSE_DISPLAY_TAB -
        (hdr ? 2 : 0);
    for (i= 0; i < parse_display_x; i++) {
        if (i % PARSE_DISPLAY_TAB == PARSE_DISPLAY_TAB - 2)
            putchar(parse_display_bar[i / PARSE_DISPLAY_TAB]);
        else putchar(' ');
    }
}
@| pprint_nl @}

\cont ¦pprint_tok()¦ prints the token starting at the position it is given
and ending at the next newline.

@d Pretty print a token
@{
char *pprint_tok(char *p)
{
    char *q, c;

    for (q= p; *q && *q != '\n'; q++);
    c= *q;
    *q= '\0';
    parse_display_x += strlen(p);
    printf(p);
    *q= c;

    return q;
}
@| pprint_tok @}

\cont First the string is written into a buffer, and an exception is raised
if there is an error or the string is too long (although in the latter case
the program may crash):

@d Pretty print a string
@{
void pprint(const char *format, ...)
{
    static int nl_flag= FALSE;
    char s[1024];
    char *p= s;
    va_list ap= va_start(ap, format);
    int len= vsprintf(s, format, ap);

    if (len < 0 || len > 1023) except(EXC_FATALN, "string too long");
@| pprint @}

\cont Next, the string is scanned and printed. When a newline is encountered
it is not printed immediately, but ¦nl_flag¦ is set to ¦TRUE¦ and
¦parse_display_x¦ to 0. This allows the indenting level to be correct when
the newline is printed, just before the next printing character.

@d Pretty print a string
@{
    while (*p)
        switch (*p) {
            case '\n':
                nl_flag= TRUE;
                pprint_nl(FALSE);
                p++;
                break;
            default:
                if (nl_flag) {
                    pprint_nl(TRUE);
                    nl_flag= FALSE;
                }
                p= pprint_tok(p);
                break;
        }
}
@| pprint @}


\subsection{Displaying the tree}

The display routines have a simple recursive descent structure like the
grammar. When an illegal token tag is found, an exception is raised using
¦PTREE_EXCEPTION¦. This may not happen at the earliest point at which the
error could be detected: when a token such as an \nont{atom}, which has no
particular tag, is expected, the appropriate display routine, in this case
¦display_atom()¦, is called without checking whether the current node is
really an \nont{atom}. So for example an illegal \nont{atom} would be passed
to ¦display_atom()¦, which would pass it to ¦display_exp()¦; only then would
it be trapped. Since all such errors indicate a bug in the program, this is
not a problem.

@d Display the parse tree
@{
void parse_display(parse_node *ptr)
{
    int i;

    parse_display_x= 0;
    parse_display_indent= 0;
    for (i= 0; i < 32; i++) parse_display_bar[i]= ' ';

    display_exps(ptr, FALSE);
    printf("\r");
}
@| parse_display @}

\cont ¦display_exps()¦ and functions like it which deal with lists have a
second parameter, ¦rec¦, which is set to ¦FALSE¦ when the function is called
from another function and to ¦TRUE¦ when the function recurses. This is used
to switch the bars on and off properly.

@d Display an \nont{exps}
@{
void display_exps(parse_node *ptr, int rec)
{
    switch (ptr->type) {
        case TOK_EXPS:
            if (SUBNODE(ptr, 0)) {
                if (!rec) {
                    pprint_header("exps");
                    pprint_bar_on();
                }
                display_exps(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_exp(SUBNODE(ptr, 1));
            if (!rec && SUBNODE(ptr, 0)) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_exps @}

@d Display an \nont{exp}
@{
void display_exp(parse_node *ptr)
{
    pprint_header("exp");
    switch (ptr->type) {
        case TOK_BLOCK:
            display_block(ptr);
            break;
        case TOK_ASSES:
            display_asses(ptr, FALSE);
            break;
        case TOK_THEN:
        case TOK_ELSE:
            display_if(ptr);
            break;
        case TOK_WHILE:
            display_while(ptr);
            break;
        case TOK_FUNC:
            display_func(ptr);
            break;
        case TOK_APP:
            display_app(ptr, FALSE);
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_end();
}
@| display_exp @}

@d Display a \nont{block}
@{
void display_block(parse_node *ptr)
{
    pprint_header("block");
    switch (ptr->type) {
        case TOK_BLOCK:
            if (SUBNODE(ptr, 0)) {
                pprint_bar_on();
                display_decls(SUBNODE(ptr, 0), FALSE);
            }
            pprint_bar_off();
            display_exps(SUBNODE(ptr, 1), FALSE);
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_end();
}
@| display_block @}

@d Display a \nont{decls}
@{
void display_decls(parse_node *ptr, int rec)
{
    switch (ptr->type) {
        case TOK_DECLS:
            if (SUBNODE(ptr, 0)) {
                if (!rec) {
                    pprint_header("display_decls");
                    pprint_bar_on();
                }
                display_decls(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_decl(SUBNODE(ptr, 1));
            if (!rec && SUBNODE(ptr, 0)) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_decls @}

@d Display a \nont{decl}
@{
void display_decl(parse_node *ptr)
{
    pprint_header("decl");
    switch (ptr->type) {
        case TOK_VAR:
            display_var(ptr);
            break;
        default:
            display_asses(ptr, FALSE);
            break;
    }
    pprint_end();
}
@| display_decl @}

@d Display an \nont{asses}
@{
void display_asses(parse_node *ptr, int rec)
{
    switch (ptr->type) {
        case TOK_ASSES:
            if (SUBNODE(ptr, 0)) {
                if (!rec) {
                    pprint_header("asses");
                    pprint_bar_on();
                }
                display_asses(SUBNODE(ptr, 0), FALSE);
                if (!rec) pprint_bar_off();
            }
            display_ass(SUBNODE(ptr, 1));
            if (!rec && SUBNODE(ptr, 0)) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_asses @}

@d Display an \nont{ass}
@{
void display_ass(parse_node *ptr)
{
    pprint_header("ass");
    switch (ptr->type) {
        case TOK_ASS:
            pprint_bar_on();
            display_var(SUBNODE(ptr, 0));
            pprint_bar_off();
            display_exp(SUBNODE(ptr, 1));
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_end();
}
@| display_ass @}

@d Display an \nont{if}
@{
void display_if(parse_node *ptr)
{
    pprint_header("if");
    pprint_bar_on();
    display_app(SUBNODE(ptr, 0), FALSE);
    if (ptr->type == TOK_THEN) pprint_bar_off();
    display_exp(SUBNODE(ptr, 1));
    pprint_bar_off();
    if (ptr->type == TOK_ELSE) display_exp(SUBNODE(ptr, 2));
    pprint_end();
}
@| display_if @}

@d Display a \nont{while}
@{
void display_while(parse_node *ptr)
{
    pprint_header("while");
    pprint_bar_off();
    display_app(SUBNODE(ptr, 0), FALSE);
    pprint_bar_off();
    display_exp(SUBNODE(ptr, 1));
    pprint_end();
}
@| display_while @}

@d Display an \nont{app}
@{
void display_app(parse_node *ptr, int rec)
{
    switch (ptr->type) {
        case TOK_APP:
            if (SUBNODE(ptr, 0)) {
                if (!rec) {
                    pprint_header("app");
                    pprint_bar_on();
                }
                display_app(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_val(SUBNODE(ptr, 1));
            if (!rec && SUBNODE(ptr, 0)) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_app @}

@d Display a \nont{func}
@{
void display_func(parse_node *ptr)
{
    pprint_header("func");
    switch (ptr->type) {
        case TOK_FUNC:
            pprint_bar_on();
            display_var(SUBNODE(ptr, 0));
            pprint_bar_off();
            display_exp(SUBNODE(ptr, 1));
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_end();
}
@| display_func @}

@d Display a \nont{val}
@{
void display_val(parse_node *ptr)
{
    switch (ptr->type) {
        case '$':
        case TOK_SLICE:
            display_slice(ptr);
            break;
        case '.':
        case ':':
            display_sel(ptr);
            break;
        case TOK_NULL:
            pprint(": null\n");
            break;
        default:
            display_list(ptr);
            break;
    }
}
@| display_val @}

@d Display a \nont{slice}
@{
void display_slice(parse_node *ptr)
{
    switch (ptr->type) {
        case '$':
            pprint_header("slice$");
            break;
        case TOK_SLICE:
            pprint_header("slice$$");
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_bar_on();
    display_list(SUBNODE(ptr, 0));
    pprint_bar_off();
    display_val(SUBNODE(ptr, 1));
    pprint_end();
}
@| display_slice @}

@d Display a \nont{sel}
@{
void display_sel(parse_node *ptr)
{
    switch (ptr->type) {
        case '.':
            pprint_header("sel.");
            break;
        case ':':
            pprint_header("sel:");
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_bar_on();
    display_list(SUBNODE(ptr, 0));
    pprint_bar_off();
    display_val(SUBNODE(ptr, 1));
    pprint_end();
}
@| display_sel @}

@d Display a \nont{list}
@{
void display_list(parse_node *ptr)
{
    switch (ptr->type) {
        case TOK_ABS_LIST:
            display_abs_list(ptr, FALSE);
            break;
        case TOK_MOD_LIST:
            display_mod_list(ptr, FALSE);
            break;
        case TOK_CONC_LIST:
            display_conc_list(ptr, FALSE);
            break;
        default:
            display_atom(ptr);
            break;
    }
}
@| display_list @}

@d Display an abstract \nont{list}
@{
void display_abs_list(parse_node *ptr, int rec)
{
    if (!rec) pprint_header("abs_list");
    switch (ptr->type) {
        case TOK_ABS_LIST:
            if (SUBNODE(ptr, 0)) {
                if (!rec) pprint_bar_on();
                display_abs_list(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_ass(SUBNODE(ptr, 1));
            if (!rec) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_abs_list @}

@d Display a concrete \nont{list}
@{
void display_conc_list(parse_node *ptr, int rec)
{
    if (!rec) pprint_header("conc_list");
    switch (ptr->type) {
        case TOK_CONC_LIST:
            if (SUBNODE(ptr, 0)) {
                if (!rec) pprint_bar_on();
                display_conc_list(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_app(SUBNODE(ptr, 1), FALSE);
            if (!rec) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_conc_list @}

@d Display a modifier \nont{list}
@{
void display_mod_list(parse_node *ptr, int rec)
{
    if (!rec) pprint_header("mod_list");
    switch (ptr->type) {
        case TOK_MOD_LIST:
            if (SUBNODE(ptr, 0)) {
                if (!rec) pprint_bar_on();
                display_mod_list(SUBNODE(ptr, 0), TRUE);
                if (!rec) pprint_bar_off();
            }
            display_elem(SUBNODE(ptr, 1));
            if (!rec) pprint_end();
            break;
        case NULL:
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_mod_list @}

@d Display an \nont{elem}
@{
void display_elem(parse_node *ptr)
{
    switch (ptr->type) {
        case TOK_ORD:
            pprint_header("ord");
            break;
        case TOK_KEY:
            pprint_header("key");
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
    pprint_bar_on();
    display_app(SUBNODE(ptr, 0), FALSE);
    pprint_bar_off();
    display_app(SUBNODE(ptr, 0), FALSE);
    pprint_end();
}
@| display_elem @}

@d Display an \nont{atom}
@{
void display_atom(parse_node *ptr)
{
    switch (ptr->type) {
        case TOK_COUNT:
            pprint_header("count");
            display_list(SUBNODE(ptr, 0));
            pprint_end();
            break;
        case TOK_VAR:
            display_var(ptr);
            break;
        case TOK_FALSE:
            pprint(": false\n");
            break;
        case TOK_TRUE:
            pprint(": true\n");
            break;
        case TOK_INT:
            pprint_header("int");
            pprint_end();
            pprint(": %ld\n", SUBNODE(ptr, 0));
            break;
        case TOK_STRING:
            pprint_header("string");
            pprint_end();
            pprint(": \"%s\"\n", (char *)SUBNODE(ptr, 0));
            break;
        default:
            display_exp(ptr);
            break;
    }
}
@| display_atom @}

@d Display a \nont{var}
@{
void display_var(parse_node *ptr)
{
    pprint_header("var");
    switch (ptr->type) {
        case TOK_VAR:
            pprint_end();
            pprint(": %s\n", (char *)SUBNODE(ptr, 0));
            break;
        default:
            PTREE_EXCEPTION;
            break;
    }
}
@| display_var @}



\section{The C source files}

\subsection{\tt gnat.h}

This declares the external variables and the functions, includes the
portability header, provides some useful macros and defines data types.

@O gnat.h -d
@{
#ifndef GNAT_GNAT
#define GNAT_GNAT

/* #include "portab.h" */
#include <stdio.h>

extern char *prog_name;
extern void yyfrom(FILE *file);
extern int yyparse(void);
extern int yydebug;
@<Truth values@>
@<Debugging message@>
@<Parse tree node structure@>
extern parse_node *gnat_program;
@<Create a parse tree node@>

void pprint_header(char *s);
void pprint_end(void);
void pprint_bar_on(void);
void pprint_bar_off(void);
void pprint_nl(int hdr);
char *pprint_tok(char *p);
void pprint(const char *format, ...);

void parse_display(parse_node *ptr);
void display_exps(parse_node *ptr, int rec);
void display_exp(parse_node *ptr);
void display_block(parse_node *ptr);
void display_decls(parse_node *ptr, int rec);
void display_decl(parse_node *ptr);
void display_asses(parse_node *ptr, int rec);
void display_ass(parse_node *ptr);
void display_if(parse_node *ptr);
void display_while(parse_node *ptr);
void display_app(parse_node *ptr, int rec);
void display_func(parse_node *ptr);
void display_val(parse_node *ptr);
void display_slice(parse_node *ptr);
void display_sel(parse_node *ptr);
void display_list(parse_node *ptr);
void display_abs_list(parse_node *ptr, int rec);
void display_conc_list(parse_node *ptr, int rec);
void display_mod_list(parse_node *ptr, int rec);
void display_elem(parse_node *ptr);
void display_atom(parse_node *ptr);
void display_var(parse_node *ptr);
#endif
@}


\subsection{\tt gnat.c}

This contains the code generator and debugging code. First, the name is
defined and header files are included:

@o gnat.c -d
@{
#include <stdio.h>
#include <except.h>
#include "gnat.h"
#include "gnattab.h"
@}

Next, ¦prog_name¦ is defined:

@o gnat.c -d
@{char *prog_name= "gnat";
@| prog_name @}

The pointer to the program:

@o gnat.c -d
@{parse_node *gnat_program;
@| gnat_program @}

The parse tree macros:

@o gnat.c -d
@{@<Raise exception for bad parse tree@>
@}

The pretty printing routines:

@o gnat.c -d
@{
@<Parse tree display parameters@>
@<Print parse tree node header@>
@<Finish a parse tree node@>
@<Add a bar@>
@<Remove a bar@>
@<Pretty print a newline@>
@<Pretty print a token@>
@<Pretty print a string@>
@<Display the parse tree@>
@<Display an \nont{exps}@>
@<Display an \nont{exp}@>
@<Display a \nont{block}@>
@<Display a \nont{decls}@>
@<Display a \nont{decl}@>
@<Display an \nont{asses}@>
@<Display an \nont{ass}@>
@<Display an \nont{if}@>
@<Display a \nont{while}@>
@<Display an \nont{app}@>
@<Display a \nont{func}@>
@<Display a \nont{val}@>
@<Display a \nont{slice}@>
@<Display a \nont{sel}@>
@<Display a \nont{list}@>
@<Display an abstract \nont{list}@>
@<Display a concrete \nont{list}@>
@<Display a modifier \nont{list}@>
@<Display an \nont{elem}@>
@<Display an \nont{atom}@>
@<Display a \nont{var}@>
@}

Finally, ¦main()¦ is defined. The program takes an optional input file; if
none is given, it reads from ¦stdin¦.

@o gnat.c -d
@{
int main(int argc, char *argv[])
{
    ++argv, --argc;
    if (argc > 0) yyfrom(fopen(argv[0], "r"));
    else yyfrom(stdin);

/*     yydebug= 1; */
    if (yyparse() == 0) parse_display(gnat_program);

    return 0;
}
@| main @}



\end{document}
